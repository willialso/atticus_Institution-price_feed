{"version":3,"file":"webauthn.js","sourceRoot":"","sources":["../../../src/identity/webauthn.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  type DerEncodedPublicKey,\n  type PublicKey,\n  type Signature,\n  SignIdentity,\n  wrapDER,\n  DER_COSE_OID,\n  Cbor,\n} from '@dfinity/agent';\nimport { bytesToHex, hexToBytes, randomBytes, bytesToUtf8 } from '@noble/hashes/utils';\nimport { uint8FromBufLike } from '@dfinity/candid';\n\nfunction _coseToDerEncodedBlob(cose: Uint8Array): DerEncodedPublicKey {\n  return wrapDER(cose, DER_COSE_OID) as DerEncodedPublicKey;\n}\n\ntype PublicKeyCredentialWithAttachment = PublicKeyCredential & {\n  // Extends `PublicKeyCredential` with an optional field introduced in the WebAuthn level 3 spec:\n  // https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment\n  // Already supported by Chrome, Safari and Edge\n  // Note: `null` is included here as a possible value because Edge set this value to null in the\n  // past.\n  authenticatorAttachment: AuthenticatorAttachment | undefined | null;\n  // Explicitly including toJSON method from the base PublicKeyCredential interface\n  toJSON: () => Record<string, unknown>;\n};\n\n/**\n * From the documentation;\n * The authData is a byte array described in the spec. Parsing it will involve slicing bytes from\n * the array and converting them into usable objects.\n *\n * See https://webauthn.guide/#registration (subsection \"Example: Parsing the authenticator data\").\n * @param authData The authData field of the attestation response.\n * @returns The COSE key of the authData.\n */\nfunction _authDataToCose(authData: Uint8Array): Uint8Array {\n  const dataView = new DataView(new ArrayBuffer(2));\n  const idLenBytes = authData.slice(53, 55);\n  [...new Uint8Array(idLenBytes)].forEach((v, i) => dataView.setUint8(i, v));\n  const credentialIdLength = dataView.getUint16(0);\n\n  // Get the public key object.\n  return authData.slice(55 + credentialIdLength);\n}\n\nexport class CosePublicKey implements PublicKey {\n  protected _encodedKey: DerEncodedPublicKey;\n\n  public constructor(protected _cose: Uint8Array) {\n    this._encodedKey = _coseToDerEncodedBlob(_cose);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this._encodedKey;\n  }\n\n  public getCose(): Uint8Array {\n    return this._cose;\n  }\n}\n\n/**\n * Create a challenge from a string or array. The default challenge is always the same\n * because we don't need to verify the authenticity of the key on the server (we don't\n * register our keys with the IC). Any challenge would do, even one per key, randomly\n * generated.\n * @param challenge The challenge to transform into a byte array. By default a hard\n *        coded string.\n */\nfunction _createChallengeBuffer(challenge: string | Uint8Array = '<ic0.app>'): Uint8Array {\n  if (typeof challenge === 'string') {\n    return Uint8Array.from(challenge, c => c.charCodeAt(0));\n  } else {\n    return challenge;\n  }\n}\n\n/**\n * Create a credentials to authenticate with a server. This is necessary in order in\n * WebAuthn to get credentials IDs (which give us the public key and allow us to\n * sign), but in the case of the Internet Computer, we don't actually need to register\n * it, so we don't.\n * @param credentialCreationOptions an optional CredentialCreationOptions object\n */\nasync function _createCredential(\n  credentialCreationOptions?: CredentialCreationOptions,\n): Promise<PublicKeyCredentialWithAttachment | null> {\n  const creds = (await navigator.credentials.create(\n    credentialCreationOptions ?? {\n      publicKey: {\n        authenticatorSelection: {\n          userVerification: 'preferred',\n        },\n        attestation: 'direct',\n        challenge: _createChallengeBuffer(),\n        pubKeyCredParams: [{ type: 'public-key', alg: PubKeyCoseAlgo.ECDSA_WITH_SHA256 }],\n        rp: {\n          name: 'Internet Identity Service',\n        },\n        user: {\n          id: randomBytes(16),\n          name: 'Internet Identity',\n          displayName: 'Internet Identity',\n        },\n      },\n    },\n  )) as PublicKeyCredentialWithAttachment | null;\n\n  if (creds === null) {\n    return null;\n  }\n\n  return {\n    // do _not_ use ...creds here, as creds is not enumerable in all cases\n    id: creds.id,\n    response: creds.response,\n    type: creds.type,\n    authenticatorAttachment: creds.authenticatorAttachment,\n    getClientExtensionResults: creds.getClientExtensionResults,\n    // Some password managers will return a Uint8Array, so we ensure we return an ArrayBuffer.\n    rawId: creds.rawId,\n    toJSON: creds.toJSON.bind(creds), // Ensure the toJSON method is included\n  };\n}\n\n// See https://www.iana.org/assignments/cose/cose.xhtml#algorithms for a complete\n// list of these algorithms. We only list the ones we support here.\nenum PubKeyCoseAlgo {\n  ECDSA_WITH_SHA256 = -7,\n}\n\n/**\n * A SignIdentity that uses `navigator.credentials`. See https://webauthn.guide/ for\n * more information about WebAuthentication.\n */\nexport class WebAuthnIdentity extends SignIdentity {\n  /**\n   * Create an identity from a JSON serialization.\n   * @param json - json to parse\n   */\n  public static fromJSON(json: string): WebAuthnIdentity {\n    const { publicKey, rawId } = JSON.parse(json);\n\n    if (typeof publicKey !== 'string' || typeof rawId !== 'string') {\n      throw new Error('Invalid JSON string.');\n    }\n\n    return new this(hexToBytes(rawId), hexToBytes(publicKey), undefined);\n  }\n\n  /**\n   * Create an identity.\n   * @param credentialCreationOptions an optional CredentialCreationOptions Challenge\n   */\n  public static async create(\n    credentialCreationOptions?: CredentialCreationOptions,\n  ): Promise<WebAuthnIdentity> {\n    const creds = await _createCredential(credentialCreationOptions);\n\n    if (!creds || creds.type !== 'public-key') {\n      throw new Error('Could not create credentials.');\n    }\n\n    const response = creds.response as AuthenticatorAttestationResponse;\n    if (response.attestationObject === undefined) {\n      throw new Error('Was expecting an attestation response.');\n    }\n\n    // Parse the attestationObject as CBOR.\n    const attObject = Cbor.decode<{ authData: Uint8Array }>(\n      new Uint8Array(response.attestationObject),\n    );\n\n    return new this(\n      uint8FromBufLike(creds.rawId),\n      _authDataToCose(attObject.authData),\n      creds.authenticatorAttachment ?? undefined,\n    );\n  }\n\n  protected _publicKey: CosePublicKey;\n\n  public constructor(\n    public readonly rawId: Uint8Array,\n    cose: Uint8Array,\n    protected authenticatorAttachment: AuthenticatorAttachment | undefined,\n  ) {\n    super();\n    this._publicKey = new CosePublicKey(cose);\n  }\n\n  public getPublicKey(): PublicKey {\n    return this._publicKey;\n  }\n\n  /**\n   * WebAuthn level 3 spec introduces a new attribute on successful WebAuthn interactions,\n   * see https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment.\n   * This attribute is already implemented for Chrome, Safari and Edge.\n   *\n   * Given the attribute is only available after a successful interaction, the information is\n   * provided opportunistically and might also be `undefined`.\n   */\n  public getAuthenticatorAttachment(): AuthenticatorAttachment | undefined {\n    return this.authenticatorAttachment;\n  }\n\n  public async sign(blob: Uint8Array): Promise<Signature> {\n    const result = (await navigator.credentials.get({\n      publicKey: {\n        allowCredentials: [\n          {\n            type: 'public-key',\n            id: this.rawId,\n          },\n        ],\n        challenge: blob,\n        userVerification: 'preferred',\n      },\n    })) as PublicKeyCredentialWithAttachment;\n\n    if (result.authenticatorAttachment !== null) {\n      this.authenticatorAttachment = result.authenticatorAttachment;\n    }\n\n    const response = result.response as AuthenticatorAssertionResponse;\n\n    const encoded = Cbor.encode({\n      authenticator_data: response.authenticatorData,\n      client_data_json: bytesToUtf8(new Uint8Array(response.clientDataJSON)),\n      signature: response.signature,\n    });\n\n    if (!encoded) {\n      throw new Error('failed to encode cbor');\n    }\n\n    Object.assign(encoded, {\n      __signature__: undefined,\n    });\n\n    return encoded as Signature;\n  }\n\n  /**\n   * Allow for JSON serialization of all information needed to reuse this identity.\n   */\n  public toJSON(): JsonnableWebAuthnIdentity {\n    return {\n      publicKey: bytesToHex(this._publicKey.getCose()),\n      rawId: bytesToHex(this.rawId),\n    };\n  }\n}\n\n/**\n * ReturnType<WebAuthnIdentity.toJSON>\n */\nexport interface JsonnableWebAuthnIdentity {\n  // The hexadecimal representation of the DER encoded public key.\n  publicKey: string;\n  // The string representation of the local WebAuthn Credential.id (base64url encoded).\n  rawId: string;\n}\n"]}