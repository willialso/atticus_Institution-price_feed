{"version":3,"file":"idl.js","sourceRoot":"","sources":["../../src/idl.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Principal as PrincipalId } from '@dfinity/principal';\nimport { type JsonValue } from './types.ts';\nimport { concat, PipeArrayBuffer as Pipe, uint8ToDataView } from './utils/buffer.ts';\nimport { idlLabelToId } from './utils/hash.ts';\nimport {\n  lebDecode,\n  lebEncode,\n  readIntLE,\n  readUIntLE,\n  safeRead,\n  safeReadUint8,\n  slebDecode,\n  slebEncode,\n  writeIntLE,\n  writeUIntLE,\n} from './utils/leb128.ts';\nimport { iexp2 } from './utils/bigint-math.ts';\n\n/**\n * This module provides a combinator library to create serializers/deserializers\n * between JavaScript values and IDL used by canisters on the Internet Computer,\n * as documented at https://github.com/dfinity/candid/blob/119703ba342d2fef6ab4972d2541b9fe36ae8e36/spec/Candid.md\n */\n\nenum IDLTypeIds {\n  Null = -1,\n  Bool = -2,\n  Nat = -3,\n  Int = -4,\n  Float32 = -13,\n  Float64 = -14,\n  Text = -15,\n  Reserved = -16,\n  Empty = -17,\n  Opt = -18,\n  Vector = -19,\n  Record = -20,\n  Variant = -21,\n  Func = -22,\n  Service = -23,\n  Principal = -24,\n}\n\nconst magicNumber = 'DIDL';\nconst toReadableString_max = 400; // will not display arguments after 400chars. Makes sure 2mb blobs don't get inside the error\n\nfunction zipWith<TX, TY, TR>(xs: TX[], ys: TY[], f: (a: TX, b: TY) => TR): TR[] {\n  return xs.map((x, i) => f(x, ys[i]));\n}\n\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n  // List of types. Needs to be an array as the index needs to be stable.\n  private _typs: Uint8Array[] = [];\n  private _idx = new Map<string, number>();\n\n  public has(obj: ConstructType) {\n    return this._idx.has(obj.name);\n  }\n\n  public add<T>(type: ConstructType<T>, buf: Uint8Array) {\n    const idx = this._typs.length;\n    this._idx.set(type.name, idx);\n    this._typs.push(buf);\n  }\n\n  public merge<T>(obj: ConstructType<T>, knot: string) {\n    const idx = this._idx.get(obj.name);\n    const knotIdx = this._idx.get(knot);\n    if (idx === undefined) {\n      throw new Error('Missing type index for ' + obj);\n    }\n    if (knotIdx === undefined) {\n      throw new Error('Missing type index for ' + knot);\n    }\n    this._typs[idx] = this._typs[knotIdx];\n\n    // Delete the type.\n    this._typs.splice(knotIdx, 1);\n    this._idx.delete(knot);\n  }\n\n  public encode(): Uint8Array {\n    const len = lebEncode(this._typs.length);\n    const buf = concat(...this._typs);\n    return concat(len, buf);\n  }\n\n  public indexOf(typeName: string): Uint8Array {\n    if (!this._idx.has(typeName)) {\n      throw new Error('Missing type index for ' + typeName);\n    }\n    return slebEncode(this._idx.get(typeName) || 0);\n  }\n}\n\nexport abstract class Visitor<D, R> {\n  public visitType<T>(_t: Type<T>, _data: D): R {\n    throw new Error('Not implemented');\n  }\n  public visitPrimitive<T>(t: PrimitiveType<T>, data: D): R {\n    return this.visitType(t, data);\n  }\n  public visitEmpty(t: EmptyClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitBool(t: BoolClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitNull(t: NullClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitReserved(t: ReservedClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitText(t: TextClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitNumber<T>(t: PrimitiveType<T>, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitInt(t: IntClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitNat(t: NatClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitFloat(t: FloatClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitFixedInt(t: FixedIntClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitFixedNat(t: FixedNatClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitPrincipal(t: PrincipalClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n\n  public visitConstruct<T>(t: ConstructType<T>, data: D): R {\n    return this.visitType(t, data);\n  }\n  public visitVec<T>(t: VecClass<T>, _ty: Type<T>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitOpt<T>(t: OptClass<T>, _ty: Type<T>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitRecord(t: RecordClass, _fields: Array<[string, Type]>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitTuple<T extends any[]>(t: TupleClass<T>, components: Type[], data: D): R {\n    const fields: Array<[string, Type]> = components.map((ty, i) => [`_${i}_`, ty]);\n    return this.visitRecord(t, fields, data);\n  }\n  public visitVariant(t: VariantClass, _fields: Array<[string, Type]>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitRec<T>(_t: RecClass<T>, ty: ConstructType<T>, data: D): R {\n    return this.visitConstruct(ty, data);\n  }\n  public visitFunc(t: FuncClass, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitService(t: ServiceClass, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n}\n\n// We try to use hard-to-accidentally-pick names to avoid potential collisions with other types.\nenum IdlTypeName {\n  EmptyClass = '__IDL_EmptyClass__',\n  UnknownClass = '__IDL_UnknownClass__',\n  BoolClass = '__IDL_BoolClass__',\n  NullClass = '__IDL_NullClass__',\n  ReservedClass = '__IDL_ReservedClass__',\n  TextClass = '__IDL_TextClass__',\n  IntClass = '__IDL_IntClass__',\n  NatClass = '__IDL_NatClass__',\n  FloatClass = '__IDL_FloatClass__',\n  FixedIntClass = '__IDL_FixedIntClass__',\n  FixedNatClass = '__IDL_FixedNatClass__',\n  VecClass = '__IDL_VecClass__',\n  OptClass = '__IDL_OptClass__',\n  RecordClass = '__IDL_RecordClass__',\n  TupleClass = '__IDL_TupleClass__',\n  VariantClass = '__IDL_VariantClass__',\n  RecClass = '__IDL_RecClass__',\n  PrincipalClass = '__IDL_PrincipalClass__',\n  FuncClass = '__IDL_FuncClass__',\n  ServiceClass = '__IDL_ServiceClass__',\n}\n\n/**\n * Represents an IDL type.\n */\nexport abstract class Type<T = any> {\n  public abstract readonly typeName: IdlTypeName;\n  public abstract readonly name: string;\n  public abstract accept<D, R>(v: Visitor<D, R>, d: D): R;\n\n  /* Display type name */\n  public display(): string {\n    return this.name;\n  }\n\n  public valueToString(x: T): string {\n    return toReadableString(x);\n  }\n\n  /* Implement `T` in the IDL spec, only needed for non-primitive types */\n  public buildTypeTable(typeTable: TypeTable): void {\n    if (!typeTable.has(this)) {\n      this._buildTypeTableImpl(typeTable);\n    }\n  }\n\n  /**\n   * Assert that JavaScript's `x` is the proper type represented by this\n   * Type.\n   */\n  public abstract covariant(x: any): x is T;\n\n  /**\n   * Encode the value. This needs to be public because it is used by\n   * encodeValue() from different types.\n   * @internal\n   */\n  public abstract encodeValue(x: T): Uint8Array;\n\n  /**\n   * Implement `I` in the IDL spec.\n   * Encode this type for the type table.\n   */\n  public abstract encodeType(typeTable: TypeTable): Uint8Array;\n\n  public abstract checkType(t: Type): Type;\n\n  public abstract decodeValue(x: Pipe, t: Type): T;\n\n  protected abstract _buildTypeTableImpl(typeTable: TypeTable): void;\n}\n\nexport abstract class PrimitiveType<T = any> extends Type<T> {\n  public checkType(t: Type): Type {\n    if (this.name !== t.name) {\n      throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    return t;\n  }\n\n  public _buildTypeTableImpl(_typeTable: TypeTable): void {\n    // No type table encoding for Primitive types.\n    return;\n  }\n}\n\nexport abstract class ConstructType<T = any> extends Type<T> {\n  public checkType(t: Type): ConstructType<T> {\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      }\n      return ty;\n    }\n    throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n  }\n  public encodeType(typeTable: TypeTable) {\n    return typeTable.indexOf(this.name);\n  }\n}\n\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nexport class EmptyClass extends PrimitiveType<never> {\n  get typeName() {\n    return IdlTypeName.EmptyClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is EmptyClass {\n    return instance.typeName === IdlTypeName.EmptyClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitEmpty(this, d);\n  }\n\n  public covariant(x: any): x is never {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): never {\n    throw new Error('Empty cannot appear as a function argument');\n  }\n\n  public valueToString(): never {\n    throw new Error('Empty cannot appear as a value');\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Empty);\n  }\n\n  public decodeValue(): never {\n    throw new Error('Empty cannot appear as an output');\n  }\n\n  get name() {\n    return 'empty';\n  }\n}\n\n/**\n * Represents an IDL Unknown, a placeholder type for deserialization only.\n * When decoding a value as Unknown, all fields will be retained but the names are only available in\n * hashed form.\n * A deserialized unknown will offer it's actual type by calling the `type()` function.\n * Unknown cannot be serialized and attempting to do so will throw an error.\n */\nexport class UnknownClass extends Type {\n  get typeName() {\n    return IdlTypeName.UnknownClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is UnknownClass {\n    return instance.typeName === IdlTypeName.UnknownClass;\n  }\n\n  public checkType(_t: Type): Type {\n    throw new Error('Method not implemented for unknown.');\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    throw v.visitType(this, d);\n  }\n\n  public covariant(x: any): x is any {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): never {\n    throw new Error('Unknown cannot appear as a function argument');\n  }\n\n  public valueToString(): never {\n    throw new Error('Unknown cannot appear as a value');\n  }\n\n  public encodeType(): never {\n    throw new Error('Unknown cannot be serialized');\n  }\n\n  public decodeValue(b: Pipe, t: Type): any {\n    let decodedValue = t.decodeValue(b, t);\n\n    if (Object(decodedValue) !== decodedValue) {\n      // decodedValue is primitive. Box it, otherwise we cannot add the type() function.\n      // The type() function is important for primitives because otherwise we cannot tell apart the\n      // different number types.\n      decodedValue = Object(decodedValue);\n    }\n\n    let typeFunc;\n    if (t instanceof RecClass) {\n      typeFunc = () => t.getType();\n    } else {\n      typeFunc = () => t;\n    }\n    // Do not use 'decodedValue.type = typeFunc' because this would lead to an enumerable property\n    // 'type' which means it would be serialized if the value would be candid encoded again.\n    // This in turn leads to problems if the decoded value is a variant because these values are\n    // only allowed to have a single property.\n    Object.defineProperty(decodedValue, 'type', {\n      value: typeFunc,\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n    return decodedValue;\n  }\n\n  protected _buildTypeTableImpl(): void {\n    throw new Error('Unknown cannot be serialized');\n  }\n\n  get name() {\n    return 'Unknown';\n  }\n}\n\n/**\n * Represents an IDL Bool\n */\nexport class BoolClass extends PrimitiveType<boolean> {\n  get typeName() {\n    return IdlTypeName.BoolClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is BoolClass {\n    return instance.typeName === IdlTypeName.BoolClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitBool(this, d);\n  }\n\n  public covariant(x: any): x is boolean {\n    if (typeof x === 'boolean') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: boolean): Uint8Array {\n    return new Uint8Array([x ? 1 : 0]);\n  }\n\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Bool);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    switch (safeReadUint8(b)) {\n      case 0:\n        return false;\n      case 1:\n        return true;\n      default:\n        throw new Error('Boolean value out of range');\n    }\n  }\n\n  get name() {\n    return 'bool';\n  }\n}\n\n/**\n * Represents an IDL Null\n */\nexport class NullClass extends PrimitiveType<null> {\n  get typeName() {\n    return IdlTypeName.NullClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is NullClass {\n    return instance.typeName === IdlTypeName.NullClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitNull(this, d);\n  }\n\n  public covariant(x: any): x is null {\n    if (x === null) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): Uint8Array {\n    return new Uint8Array(0);\n  }\n\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Null);\n  }\n\n  public decodeValue(_b: Pipe, t: Type) {\n    this.checkType(t);\n    return null;\n  }\n\n  get name() {\n    return 'null';\n  }\n}\n\n/**\n * Represents an IDL Reserved\n */\nexport class ReservedClass extends PrimitiveType<any> {\n  get typeName() {\n    return IdlTypeName.ReservedClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is ReservedClass {\n    return instance.typeName === IdlTypeName.ReservedClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitReserved(this, d);\n  }\n\n  public covariant(_x: any): _x is any {\n    return true;\n  }\n\n  public encodeValue(): Uint8Array {\n    return new Uint8Array(0);\n  }\n\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Reserved);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    if (t.name !== this.name) {\n      t.decodeValue(b, t);\n    }\n    return null;\n  }\n\n  get name() {\n    return 'reserved';\n  }\n}\n\n/**\n * Represents an IDL Text\n */\nexport class TextClass extends PrimitiveType<string> {\n  get typeName() {\n    return IdlTypeName.TextClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is TextClass {\n    return instance.typeName === IdlTypeName.TextClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitText(this, d);\n  }\n\n  public covariant(x: any): x is string {\n    if (typeof x === 'string') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: string) {\n    const buf = new TextEncoder().encode(x);\n    const len = lebEncode(buf.byteLength);\n    return concat(len, buf);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Text);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const len = lebDecode(b);\n    const buf = safeRead(b, Number(len));\n    const decoder = new TextDecoder('utf8', { fatal: true });\n    return decoder.decode(buf);\n  }\n\n  get name() {\n    return 'text';\n  }\n\n  public valueToString(x: string) {\n    return '\"' + x + '\"';\n  }\n}\n\n/**\n * Represents an IDL Int\n */\nexport class IntClass extends PrimitiveType<bigint> {\n  get typeName() {\n    return IdlTypeName.IntClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is IntClass {\n    return instance.typeName === IdlTypeName.IntClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitInt(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if (typeof x === 'bigint' || Number.isInteger(x)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number): Uint8Array {\n    return slebEncode(x);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Int);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return slebDecode(b);\n  }\n\n  get name() {\n    return 'int';\n  }\n\n  public valueToString(x: bigint) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Nat\n */\nexport class NatClass extends PrimitiveType<bigint> {\n  get typeName() {\n    return IdlTypeName.NatClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is NatClass {\n    return instance.typeName === IdlTypeName.NatClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitNat(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if ((typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number): Uint8Array {\n    return lebEncode(x);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Nat);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return lebDecode(b);\n  }\n\n  get name() {\n    return 'nat';\n  }\n\n  public valueToString(x: bigint) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Float\n */\nexport class FloatClass extends PrimitiveType<number> {\n  get typeName() {\n    return IdlTypeName.FloatClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FloatClass {\n    return instance.typeName === IdlTypeName.FloatClass;\n  }\n\n  constructor(public readonly _bits: number) {\n    super();\n    if (_bits !== 32 && _bits !== 64) {\n      throw new Error('not a valid float type');\n    }\n  }\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFloat(this, d);\n  }\n\n  public covariant(x: any): x is number {\n    if (typeof x === 'number' || x instanceof Number) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: number) {\n    const buf = new ArrayBuffer(this._bits / 8);\n    const view = new DataView(buf);\n    if (this._bits === 32) {\n      view.setFloat32(0, x, true);\n    } else {\n      view.setFloat64(0, x, true);\n    }\n    return new Uint8Array(buf);\n  }\n\n  public encodeType(): Uint8Array {\n    const opcode = this._bits === 32 ? IDLTypeIds.Float32 : IDLTypeIds.Float64;\n    return slebEncode(opcode);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const bytes = safeRead(b, this._bits / 8);\n    const view = uint8ToDataView(bytes);\n    if (this._bits === 32) {\n      return view.getFloat32(0, true);\n    } else {\n      return view.getFloat64(0, true);\n    }\n  }\n\n  get name() {\n    return 'float' + this._bits;\n  }\n\n  public valueToString(x: number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL fixed-width Int(n)\n */\nexport class FixedIntClass extends PrimitiveType<bigint | number> {\n  get typeName() {\n    return IdlTypeName.FixedIntClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FixedIntClass {\n    return instance.typeName === IdlTypeName.FixedIntClass;\n  }\n\n  constructor(public readonly _bits: number) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFixedInt(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    const min = iexp2(this._bits - 1) * BigInt(-1);\n    const max = iexp2(this._bits - 1) - BigInt(1);\n    let ok = false;\n    if (typeof x === 'bigint') {\n      ok = x >= min && x <= max;\n    } else if (Number.isInteger(x)) {\n      const v = BigInt(x);\n      ok = v >= min && v <= max;\n    } else {\n      ok = false;\n    }\n\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return writeIntLE(x, this._bits / 8);\n  }\n\n  public encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-9 - offset);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const num = readIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `int${this._bits}`;\n  }\n\n  public valueToString(x: bigint | number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nexport class FixedNatClass extends PrimitiveType<bigint | number> {\n  get typeName() {\n    return IdlTypeName.FixedNatClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FixedNatClass {\n    return instance.typeName === IdlTypeName.FixedNatClass;\n  }\n\n  constructor(public readonly _bits: number) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFixedNat(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    const max = iexp2(this._bits);\n    let ok = false;\n    if (typeof x === 'bigint' && x >= BigInt(0)) {\n      ok = x < max;\n    } else if (Number.isInteger(x) && x >= 0) {\n      const v = BigInt(x);\n      ok = v < max;\n    } else {\n      ok = false;\n    }\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return writeUIntLE(x, this._bits / 8);\n  }\n\n  public encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-5 - offset);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const num = readUIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `nat${this._bits}`;\n  }\n\n  public valueToString(x: bigint | number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Array\n *\n * Arrays of fixed-sized nat/int type (e.g. nat8), are encoded from and decoded to TypedArrays (e.g. Uint8Array).\n * Arrays of float or other non-primitive types are encoded/decoded as untyped array in Javascript.\n * @param {Type} t\n */\nexport class VecClass<T> extends ConstructType<T[]> {\n  get typeName() {\n    return IdlTypeName.VecClass;\n  }\n\n  static [Symbol.hasInstance]<T>(instance: any): instance is VecClass<T> {\n    return instance.typeName === IdlTypeName.VecClass;\n  }\n\n  // If true, this vector is really a blob and we can just use memcpy.\n  //\n  // NOTE:\n  // With support of encoding/dencoding of TypedArrays, this optimization is\n  // only used when plain array of bytes are passed as encoding input in order\n  // to be backward compatible.\n  private _blobOptimization = false;\n\n  constructor(public _type: Type<T>) {\n    super();\n    if (_type instanceof FixedNatClass && _type._bits === 8) {\n      this._blobOptimization = true;\n    }\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitVec(this, this._type, d);\n  }\n\n  public covariant(x: any): x is T[] {\n    // Special case for ArrayBuffer\n    const bits =\n      this._type instanceof FixedNatClass\n        ? this._type._bits\n        : this._type instanceof FixedIntClass\n          ? this._type._bits\n          : 0;\n\n    if (\n      (ArrayBuffer.isView(x) && bits == (x as any).BYTES_PER_ELEMENT * 8) ||\n      (Array.isArray(x) &&\n        x.every((v, idx) => {\n          try {\n            return this._type.covariant(v);\n          } catch (e: any) {\n            throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${idx} -> ${e.message}`);\n          }\n        }))\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: T[]): Uint8Array {\n    const len = lebEncode(x.length);\n    if (this._blobOptimization) {\n      return concat(len, new Uint8Array(x as unknown as number[]));\n    }\n\n    if (ArrayBuffer.isView(x)) {\n      // Handle TypedArrays with endianness concerns\n      if (x instanceof Int16Array || x instanceof Uint16Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 2));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof Int16Array) {\n            buffer.setInt16(i * 2, x[i], true); // true = little-endian\n          } else {\n            buffer.setUint16(i * 2, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else if (x instanceof Int32Array || x instanceof Uint32Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 4));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof Int32Array) {\n            buffer.setInt32(i * 4, x[i], true);\n          } else {\n            buffer.setUint32(i * 4, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else if (x instanceof BigInt64Array || x instanceof BigUint64Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 8));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof BigInt64Array) {\n            buffer.setBigInt64(i * 8, x[i], true);\n          } else {\n            buffer.setBigUint64(i * 8, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else {\n        // For Uint8Array, Int8Array, etc. that don't have endianness concerns\n        return concat(len, new Uint8Array(x.buffer, x.byteOffset, x.byteLength));\n      }\n    }\n    const buf = new Pipe(new Uint8Array(len.byteLength + x.length), 0);\n    buf.write(len);\n    for (const d of x) {\n      const encoded = this._type.encodeValue(d);\n      buf.write(new Uint8Array(encoded));\n    }\n    return buf.buffer;\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(IDLTypeIds.Vector);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  public decodeValue(b: Pipe, t: Type): T[] {\n    const vec = this.checkType(t);\n    if (!(vec instanceof VecClass)) {\n      throw new Error('Not a vector type');\n    }\n    const len = Number(lebDecode(b));\n\n    if (this._type instanceof FixedNatClass) {\n      if (this._type._bits == 8) {\n        return new Uint8Array(b.read(len)) as unknown as T[];\n      }\n      if (this._type._bits == 16) {\n        const bytes = b.read(len * 2);\n        // Check if we need to swap bytes for endianness\n        const u16 = new Uint16Array(bytes.buffer, bytes.byteOffset, len);\n        return u16 as unknown as T[];\n      }\n      if (this._type._bits == 32) {\n        const bytes = b.read(len * 4);\n        const u32 = new Uint32Array(bytes.buffer, bytes.byteOffset, len);\n        return u32 as unknown as T[];\n      }\n      if (this._type._bits == 64) {\n        return new BigUint64Array(b.read(len * 8).buffer) as unknown as T[];\n      }\n    }\n\n    if (this._type instanceof FixedIntClass) {\n      if (this._type._bits == 8) {\n        return new Int8Array(b.read(len)) as unknown as T[];\n      }\n      if (this._type._bits == 16) {\n        const bytes = b.read(len * 2);\n        // Create a DataView to properly handle endianness\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n        // Create result array with correct endianness\n        const result = new Int16Array(len);\n        for (let i = 0; i < len; i++) {\n          // Read each value as little-endian (Candid wire format is little-endian)\n          result[i] = view.getInt16(i * 2, true);\n        }\n        return result as unknown as T[];\n      }\n      if (this._type._bits == 32) {\n        const bytes = b.read(len * 4);\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n        const result = new Int32Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = view.getInt32(i * 4, true);\n        }\n        return result as unknown as T[];\n      }\n      if (this._type._bits == 64) {\n        const bytes = b.read(len * 8);\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n        const result = new BigInt64Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = view.getBigInt64(i * 8, true);\n        }\n        return result as unknown as T[];\n      }\n    }\n\n    const rets: T[] = [];\n    for (let i = 0; i < len; i++) {\n      rets.push(this._type.decodeValue(b, vec._type));\n    }\n    return rets;\n  }\n\n  get name() {\n    return `vec ${this._type.name}`;\n  }\n\n  public display() {\n    return `vec ${this._type.display()}`;\n  }\n\n  public valueToString(x: T[]) {\n    const elements = x.map(e => this._type.valueToString(e));\n    return 'vec {' + elements.join('; ') + '}';\n  }\n}\n\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nexport class OptClass<T> extends ConstructType<[T] | []> {\n  get typeName() {\n    return IdlTypeName.OptClass;\n  }\n\n  static [Symbol.hasInstance]<T>(instance: any): instance is OptClass<T> {\n    return instance.typeName === IdlTypeName.OptClass;\n  }\n\n  constructor(public _type: Type<T>) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitOpt(this, this._type, d);\n  }\n\n  public covariant(x: any): x is [T] | [] {\n    try {\n      if (Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0]))))\n        return true;\n    } catch (e: any) {\n      throw new Error(\n        `Invalid ${this.display()} argument: ${toReadableString(x)} \\n\\n-> ${e.message}`,\n      );\n    }\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: [T] | []): Uint8Array {\n    if (x.length === 0) {\n      return new Uint8Array([0]);\n    } else {\n      return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));\n    }\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(IDLTypeIds.Opt);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  public decodeValue(b: Pipe, t: Type): [T] | [] {\n    if (t instanceof NullClass) {\n      return [];\n    }\n\n    if (t instanceof ReservedClass) {\n      return [];\n    }\n\n    let wireType = t;\n    // unfold wireType, if needed\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      } else wireType = ty;\n    }\n\n    if (wireType instanceof OptClass) {\n      switch (safeReadUint8(b)) {\n        case 0:\n          return [];\n        case 1: {\n          // Save the current state of the Pipe `b` to allow rollback in case of an error\n          const checkpoint = b.save();\n          try {\n            // Attempt to decode a value using the `_type` of the current instance\n            const v = this._type.decodeValue(b, wireType._type);\n            return [v];\n          } catch (e: any) {\n            // If an error occurs during decoding, restore the Pipe `b` to its previous state\n            b.restore(checkpoint);\n            // Skip the value at the current wire type to advance the Pipe `b` position\n            wireType._type.decodeValue(b, wireType._type);\n            // Return an empty array to indicate a `none` value\n            return [];\n          }\n        }\n        default:\n          throw new Error('Not an option value');\n      }\n    } else if (\n      // this check corresponds to `not (null <: <t>)` in the spec\n      this._type instanceof NullClass ||\n      this._type instanceof OptClass ||\n      this._type instanceof ReservedClass\n    ) {\n      // null <: <t> :\n      // skip value at wire type (to advance b) and return \"null\", i.e. []\n      wireType.decodeValue(b, wireType);\n      return [];\n    } else {\n      // not (null <: t) :\n      // try constituent type\n      const checkpoint = b.save();\n      try {\n        const v = this._type.decodeValue(b, t);\n        return [v];\n      } catch (e: any) {\n        // decoding failed, but this is opt, so return \"null\", i.e. []\n        b.restore(checkpoint);\n        // skip value at wire type (to advance b)\n        wireType.decodeValue(b, t);\n        // return \"null\"\n        return [];\n      }\n    }\n  }\n\n  get name() {\n    return `opt ${this._type.name}`;\n  }\n\n  public display() {\n    return `opt ${this._type.display()}`;\n  }\n\n  public valueToString(x: [T] | []) {\n    if (x.length === 0) {\n      return 'null';\n    } else {\n      return `opt ${this._type.valueToString(x[0])}`;\n    }\n  }\n}\n\n/**\n * Represents an IDL Record\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class RecordClass extends ConstructType<Record<string, any>> {\n  get typeName() {\n    return IdlTypeName.RecordClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is RecordClass {\n    // TupleClass extends RecordClass, so we need to check both here\n    return (\n      instance.typeName === IdlTypeName.RecordClass || instance.typeName === IdlTypeName.TupleClass\n    );\n  }\n\n  public readonly _fields: Array<[string, Type]>;\n\n  constructor(fields: Record<string, Type> = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitRecord(this, this._fields, d);\n  }\n\n  public tryAsTuple(): Type[] | null {\n    const res: Type[] = [];\n    for (let i = 0; i < this._fields.length; i++) {\n      const [key, type] = this._fields[i];\n      if (key !== `_${i}_`) {\n        return null;\n      }\n      res.push(type);\n    }\n    return res;\n  }\n\n  public covariant(x: any): x is Record<string, any> {\n    if (\n      typeof x === 'object' &&\n      this._fields.every(([k, t]) => {\n        // eslint-disable-next-line\n        if (!x.hasOwnProperty(k)) {\n          throw new Error(`Record is missing key \"${k}\".`);\n        }\n        try {\n          return t.covariant(x[k]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nfield ${k} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: Record<string, any>): Uint8Array {\n    const values = this._fields.map(([key]) => x[key]);\n    const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Record);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) =>\n      concat(lebEncode(idlLabelToId(key)), value.encodeType(T)),\n    );\n\n    T.add(this, concat(opCode, len, concat(...fields)));\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    const record = this.checkType(t);\n    if (!(record instanceof RecordClass)) {\n      throw new Error('Not a record type');\n    }\n    const x: Record<string, any> = {};\n\n    let expectedRecordIdx = 0;\n    let actualRecordIdx = 0;\n    while (actualRecordIdx < record._fields.length) {\n      const [hash, type] = record._fields[actualRecordIdx];\n\n      if (expectedRecordIdx >= this._fields.length) {\n        // skip unexpected left over fields present on the wire\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n        continue;\n      }\n\n      const [expectKey, expectType] = this._fields[expectedRecordIdx];\n      const expectedId = idlLabelToId(this._fields[expectedRecordIdx][0]);\n      const actualId = idlLabelToId(hash);\n      if (expectedId === actualId) {\n        // the current field on the wire matches the expected field\n        x[expectKey] = expectType.decodeValue(b, type);\n        expectedRecordIdx++;\n        actualRecordIdx++;\n      } else if (actualId > expectedId) {\n        // The expected field does not exist on the wire\n        if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n          x[expectKey] = [];\n          expectedRecordIdx++;\n        } else {\n          throw new Error('Cannot find required field ' + expectKey);\n        }\n      } else {\n        // The field on the wire does not exist in the output type, so we can skip it\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n      }\n    }\n\n    // initialize left over expected optional fields\n    for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {\n      if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n        // TODO this assumes null value in opt is represented as []\n        x[expectKey] = [];\n      } else {\n        throw new Error('Cannot find required field ' + expectKey);\n      }\n    }\n    return x;\n  }\n\n  get fieldsAsObject(): Record<number, Type> {\n    const fields: Record<number, Type> = {};\n    for (const [name, ty] of this._fields) {\n      fields[idlLabelToId(name)] = ty;\n    }\n    return fields;\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public display() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: Record<string, any>) {\n    const values = this._fields.map(([key]) => x[key]);\n    const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nexport class TupleClass<T extends any[]> extends RecordClass {\n  get typeName() {\n    return IdlTypeName.TupleClass;\n  }\n\n  static [Symbol.hasInstance]<T extends any[]>(instance: any): instance is TupleClass<T> {\n    return instance.typeName === IdlTypeName.TupleClass;\n  }\n\n  protected readonly _components: Type[];\n\n  constructor(_components: Type[]) {\n    const x: Record<string, any> = {};\n    _components.forEach((e, i) => (x['_' + i + '_'] = e));\n    super(x);\n    this._components = _components;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitTuple(this, this._components, d);\n  }\n\n  public covariant(x: any): x is T {\n    // `>=` because tuples can be covariant when encoded.\n\n    if (\n      Array.isArray(x) &&\n      x.length >= this._fields.length &&\n      this._components.every((t, i) => {\n        try {\n          return t.covariant(x[i]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${i} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: any[]): Uint8Array {\n    const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  public decodeValue(b: Pipe, t: Type): T {\n    const tuple = this.checkType(t);\n    if (!(tuple instanceof TupleClass)) {\n      throw new Error('not a tuple type');\n    }\n    if (tuple._components.length < this._components.length) {\n      throw new Error('tuple mismatch');\n    }\n    const res = [];\n    for (const [i, wireType] of tuple._components.entries()) {\n      if (i >= this._components.length) {\n        // skip value\n        wireType.decodeValue(b, wireType);\n      } else {\n        res.push(this._components[i].decodeValue(b, wireType));\n      }\n    }\n    return res as T;\n  }\n\n  public display() {\n    const fields = this._components.map(value => value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public valueToString(values: any[]) {\n    const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n\n/**\n * Represents an IDL Variant\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class VariantClass extends ConstructType<Record<string, any>> {\n  get typeName() {\n    return IdlTypeName.VariantClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is VariantClass {\n    return instance.typeName === IdlTypeName.VariantClass;\n  }\n\n  public readonly _fields: Array<[string, Type]>;\n\n  constructor(fields: Record<string, Type> = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitVariant(this, this._fields, d);\n  }\n\n  public covariant(x: any): x is Record<string, any> {\n    if (\n      typeof x === 'object' &&\n      Object.entries(x).length === 1 &&\n      this._fields.every(([k, v]) => {\n        try {\n          // eslint-disable-next-line\n          return !x.hasOwnProperty(k) || v.covariant(x[k]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nvariant ${k} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: Record<string, any>) {\n    for (let i = 0; i < this._fields.length; i++) {\n      const [name, type] = this._fields[i];\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const idx = lebEncode(i);\n        const buf = type.encodeValue(x[name]);\n\n        return concat(idx, buf);\n      }\n    }\n    throw Error('Variant has no data: ' + x);\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._fields.forEach(([, type]) => {\n      type.buildTypeTable(typeTable);\n    });\n    const opCode = slebEncode(IDLTypeIds.Variant);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) =>\n      concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable)),\n    );\n    typeTable.add(this, concat(opCode, len, ...fields));\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    const variant = this.checkType(t);\n    if (!(variant instanceof VariantClass)) {\n      throw new Error('Not a variant type');\n    }\n    const idx = Number(lebDecode(b));\n    if (idx >= variant._fields.length) {\n      throw Error('Invalid variant index: ' + idx);\n    }\n    const [wireHash, wireType] = variant._fields[idx];\n    for (const [key, expectType] of this._fields) {\n      if (idlLabelToId(wireHash) === idlLabelToId(key)) {\n        const value = expectType.decodeValue(b, wireType);\n        return { [key]: value };\n      }\n    }\n    throw new Error('Cannot find field hash ' + wireHash);\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  public display() {\n    const fields = this._fields.map(\n      ([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`),\n    );\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: Record<string, any>) {\n    for (const [name, type] of this._fields) {\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const value = type.valueToString(x[name]);\n        if (value === 'null') {\n          return `variant {${name}}`;\n        } else {\n          return `variant {${name}=${value}}`;\n        }\n      }\n    }\n    throw new Error('Variant has no data: ' + x);\n  }\n\n  get alternativesAsObject(): Record<number, Type> {\n    const alternatives: Record<number, Type> = {};\n    for (const [name, ty] of this._fields) {\n      alternatives[idlLabelToId(name)] = ty;\n    }\n    return alternatives;\n  }\n}\n\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nexport class RecClass<T = any> extends ConstructType<T> {\n  get typeName() {\n    return IdlTypeName.RecClass;\n  }\n\n  private static _counter = 0;\n  private _id = RecClass._counter++;\n  private _type: ConstructType<T> | undefined;\n\n  static [Symbol.hasInstance](instance: any): instance is RecClass {\n    return instance.typeName === IdlTypeName.RecClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return v.visitRec(this, this._type, d);\n  }\n\n  public fill(t: ConstructType<T>) {\n    this._type = t;\n  }\n\n  public getType() {\n    return this._type;\n  }\n\n  public covariant(x: any): x is T {\n    if (this._type ? this._type.covariant(x) : false) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: T) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.encodeValue(x);\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    typeTable.add(this, new Uint8Array([]));\n    this._type.buildTypeTable(typeTable);\n    typeTable.merge(this, this._type.name);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.decodeValue(b, t);\n  }\n\n  get name() {\n    return `rec_${this._id}`;\n  }\n\n  public display() {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return `${this.name}.${this._type.name}`;\n  }\n\n  public valueToString(x: T) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.valueToString(x);\n  }\n}\n\nfunction decodePrincipalId(b: Pipe): PrincipalId {\n  const x = safeReadUint8(b);\n  if (x !== 1) {\n    throw new Error('Cannot decode principal');\n  }\n\n  const len = Number(lebDecode(b));\n  return PrincipalId.fromUint8Array(new Uint8Array(safeRead(b, len)));\n}\n\n/**\n * Represents an IDL principal reference\n */\nexport class PrincipalClass extends PrimitiveType<PrincipalId> {\n  get typeName() {\n    return IdlTypeName.PrincipalClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is PrincipalClass {\n    return instance.typeName === IdlTypeName.PrincipalClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitPrincipal(this, d);\n  }\n\n  public covariant(x: any): x is PrincipalId {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: PrincipalId): Uint8Array {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Principal);\n  }\n\n  public decodeValue(b: Pipe, t: Type): PrincipalId {\n    this.checkType(t);\n    return decodePrincipalId(b);\n  }\n\n  get name() {\n    return 'principal';\n  }\n  public valueToString(x: PrincipalId) {\n    return `${this.name} \"${x.toText()}\"`;\n  }\n}\n\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nexport class FuncClass extends ConstructType<[PrincipalId, string]> {\n  get typeName() {\n    return IdlTypeName.FuncClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FuncClass {\n    return instance.typeName === IdlTypeName.FuncClass;\n  }\n\n  public static argsToString(types: Type[], v: any[]) {\n    if (types.length !== v.length) {\n      throw new Error('arity mismatch');\n    }\n    return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n  }\n\n  constructor(\n    public argTypes: Type[],\n    public retTypes: Type[],\n    public annotations: string[] = [],\n  ) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFunc(this, d);\n  }\n  public covariant(x: any): x is [PrincipalId, string] {\n    if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string')\n      return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue([principal, methodName]: [PrincipalId, string]) {\n    const buf = principal.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    const canister = concat(new Uint8Array([1]), len, buf);\n\n    const method = new TextEncoder().encode(methodName);\n    const methodLen = lebEncode(method.byteLength);\n    return concat(new Uint8Array([1]), canister, methodLen, method);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this.argTypes.forEach(arg => arg.buildTypeTable(T));\n    this.retTypes.forEach(arg => arg.buildTypeTable(T));\n\n    const opCode = slebEncode(IDLTypeIds.Func);\n    const argLen = lebEncode(this.argTypes.length);\n    const args = concat(...this.argTypes.map(arg => arg.encodeType(T)));\n    const retLen = lebEncode(this.retTypes.length);\n    const rets = concat(...this.retTypes.map(arg => arg.encodeType(T)));\n    const annLen = lebEncode(this.annotations.length);\n    const anns = concat(...this.annotations.map(a => this.encodeAnnotation(a)));\n\n    T.add(this, concat(opCode, argLen, args, retLen, rets, annLen, anns));\n  }\n\n  public decodeValue(b: Pipe, t: Type): [PrincipalId, string] {\n    const tt = t instanceof RecClass ? (t.getType() ?? t) : t;\n    if (!subtype(tt, this)) {\n      throw new Error(\n        `Cannot decode function reference at type ${this.display()} from wire type ${tt.display()}`,\n      );\n    }\n    const x = safeReadUint8(b);\n    if (x !== 1) {\n      throw new Error('Cannot decode function reference');\n    }\n    const canister = decodePrincipalId(b);\n\n    const mLen = Number(lebDecode(b));\n    const buf = safeRead(b, mLen);\n    const decoder = new TextDecoder('utf8', { fatal: true });\n    const method = decoder.decode(buf);\n\n    return [canister, method];\n  }\n\n  get name() {\n    const args = this.argTypes.map(arg => arg.name).join(', ');\n    const rets = this.retTypes.map(arg => arg.name).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) -> (${rets})${annon}`;\n  }\n\n  public valueToString([principal, str]: [PrincipalId, string]) {\n    return `func \"${principal.toText()}\".${str}`;\n  }\n\n  public display(): string {\n    const args = this.argTypes.map(arg => arg.display()).join(', ');\n    const rets = this.retTypes.map(arg => arg.display()).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args})  (${rets})${annon}`;\n  }\n\n  private encodeAnnotation(ann: string): Uint8Array {\n    if (ann === 'query') {\n      return new Uint8Array([1]);\n    } else if (ann === 'oneway') {\n      return new Uint8Array([2]);\n    } else if (ann === 'composite_query') {\n      return new Uint8Array([3]);\n    } else {\n      throw new Error('Illegal function annotation');\n    }\n  }\n}\n\nexport class ServiceClass extends ConstructType<PrincipalId> {\n  get typeName() {\n    return IdlTypeName.ServiceClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is ServiceClass {\n    return instance.typeName === IdlTypeName.ServiceClass;\n  }\n\n  public readonly _fields: Array<[string, FuncClass]>;\n  constructor(fields: Record<string, FuncClass>) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => {\n      if (a[0] < b[0]) {\n        return -1;\n      }\n      if (a[0] > b[0]) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitService(this, d);\n  }\n  public covariant(x: any): x is PrincipalId {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: PrincipalId): Uint8Array {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.length);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Service);\n    const len = lebEncode(this._fields.length);\n    const meths = this._fields.map(([label, func]) => {\n      const labelBuf = new TextEncoder().encode(label);\n      const labelLen = lebEncode(labelBuf.length);\n      return concat(labelLen, labelBuf, func.encodeType(T));\n    });\n\n    T.add(this, concat(opCode, len, ...meths));\n  }\n\n  public decodeValue(b: Pipe, t: Type): PrincipalId {\n    const tt = t instanceof RecClass ? (t.getType() ?? t) : t;\n    if (!subtype(tt, this)) {\n      throw new Error(\n        `Cannot decode service reference at type ${this.display()} from wire type ${tt.display()}`,\n      );\n    }\n    return decodePrincipalId(b);\n  }\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `service {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: PrincipalId) {\n    return `service \"${x.toText()}\"`;\n  }\n\n  public fieldsAsObject() {\n    const fields: Record<string, Type> = {};\n    for (const [name, ty] of this._fields) {\n      fields[name] = ty;\n    }\n    return fields;\n  }\n}\n\n/**\n * Takes an unknown value and returns a string representation of it.\n * @param x - unknown value\n * @returns {string} string representation of the value\n */\nfunction toReadableString(x: unknown): string {\n  const str = JSON.stringify(x, (_key, value) =>\n    typeof value === 'bigint' ? `BigInt(${value})` : value,\n  );\n\n  return str && str.length > toReadableString_max\n    ? str.substring(0, toReadableString_max - 3) + '...'\n    : str;\n}\n\n/**\n * Encode a array of values\n * @param argTypes - array of Types\n * @param args - array of values\n * @returns {Uint8Array} serialised value\n */\nexport function encode(argTypes: Array<Type<any>>, args: any[]): Uint8Array {\n  if (args.length < argTypes.length) {\n    throw Error('Wrong number of message arguments');\n  }\n\n  const typeTable = new TypeTable();\n  argTypes.forEach(t => t.buildTypeTable(typeTable));\n\n  const magic = new TextEncoder().encode(magicNumber);\n  const table = typeTable.encode();\n  const len = lebEncode(args.length);\n  const typs = concat(...argTypes.map(t => t.encodeType(typeTable)));\n  const vals = concat(\n    ...zipWith(argTypes, args, (t, x) => {\n      try {\n        t.covariant(x);\n      } catch (e: any) {\n        const err = new Error(e.message + '\\n\\n');\n        throw err;\n      }\n\n      return t.encodeValue(x);\n    }),\n  );\n\n  return concat(magic, table, len, typs, vals);\n}\n\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nexport function decode(retTypes: Type[], bytes: Uint8Array): JsonValue[] {\n  const b = new Pipe(bytes);\n\n  if (bytes.byteLength < magicNumber.length) {\n    throw new Error('Message length smaller than magic number');\n  }\n  const magicBuffer = safeRead(b, magicNumber.length);\n  const magic = new TextDecoder().decode(magicBuffer);\n  if (magic !== magicNumber) {\n    throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n  }\n\n  function readTypeTable(pipe: Pipe): [Array<[IDLTypeIds, any]>, number[]] {\n    const typeTable: Array<[IDLTypeIds, any]> = [];\n    const len = Number(lebDecode(pipe));\n\n    for (let i = 0; i < len; i++) {\n      const ty = Number(slebDecode(pipe));\n      switch (ty) {\n        case IDLTypeIds.Opt:\n        case IDLTypeIds.Vector: {\n          const t = Number(slebDecode(pipe));\n          typeTable.push([ty, t]);\n          break;\n        }\n        case IDLTypeIds.Record:\n        case IDLTypeIds.Variant: {\n          const fields = [];\n          let objectLength = Number(lebDecode(pipe));\n          let prevHash;\n          while (objectLength--) {\n            const hash = Number(lebDecode(pipe));\n            if (hash >= Math.pow(2, 32)) {\n              throw new Error('field id out of 32-bit range');\n            }\n            if (typeof prevHash === 'number' && prevHash >= hash) {\n              throw new Error('field id collision or not sorted');\n            }\n            prevHash = hash;\n            const t = Number(slebDecode(pipe));\n            fields.push([hash, t]);\n          }\n          typeTable.push([ty, fields]);\n          break;\n        }\n        case IDLTypeIds.Func: {\n          const args = [];\n          let argLength = Number(lebDecode(pipe));\n          while (argLength--) {\n            args.push(Number(slebDecode(pipe)));\n          }\n          const returnValues = [];\n          let returnValuesLength = Number(lebDecode(pipe));\n          while (returnValuesLength--) {\n            returnValues.push(Number(slebDecode(pipe)));\n          }\n          const annotations = [];\n          let annotationLength = Number(lebDecode(pipe));\n          while (annotationLength--) {\n            const annotation = Number(lebDecode(pipe));\n            switch (annotation) {\n              case 1: {\n                annotations.push('query');\n                break;\n              }\n              case 2: {\n                annotations.push('oneway');\n                break;\n              }\n              case 3: {\n                annotations.push('composite_query');\n                break;\n              }\n              default:\n                throw new Error('unknown annotation');\n            }\n          }\n          typeTable.push([ty, [args, returnValues, annotations]]);\n          break;\n        }\n        case IDLTypeIds.Service: {\n          let servLength = Number(lebDecode(pipe));\n          const methods = [];\n          while (servLength--) {\n            const nameLength = Number(lebDecode(pipe));\n            const funcName = new TextDecoder().decode(safeRead(pipe, nameLength));\n            const funcType = slebDecode(pipe);\n            methods.push([funcName, funcType]);\n          }\n          typeTable.push([ty, methods]);\n          break;\n        }\n        default:\n          throw new Error('Illegal op_code: ' + ty);\n      }\n    }\n\n    const rawList: number[] = [];\n    const length = Number(lebDecode(pipe));\n    for (let i = 0; i < length; i++) {\n      rawList.push(Number(slebDecode(pipe)));\n    }\n    return [typeTable, rawList];\n  }\n  const [rawTable, rawTypes] = readTypeTable(b);\n  if (rawTypes.length < retTypes.length) {\n    throw new Error('Wrong number of return values');\n  }\n\n  const table: RecClass[] = rawTable.map(_ => Rec());\n  function getType(t: number): Type {\n    if (t < -24) {\n      throw new Error('future value not supported');\n    }\n    if (t < 0) {\n      switch (t) {\n        case -1:\n          return Null;\n        case -2:\n          return Bool;\n        case -3:\n          return Nat;\n        case -4:\n          return Int;\n        case -5:\n          return Nat8;\n        case -6:\n          return Nat16;\n        case -7:\n          return Nat32;\n        case -8:\n          return Nat64;\n        case -9:\n          return Int8;\n        case -10:\n          return Int16;\n        case -11:\n          return Int32;\n        case -12:\n          return Int64;\n        case -13:\n          return Float32;\n        case -14:\n          return Float64;\n        case -15:\n          return Text;\n        case -16:\n          return Reserved;\n        case -17:\n          return Empty;\n        case -24:\n          return Principal;\n        default:\n          throw new Error('Illegal op_code: ' + t);\n      }\n    }\n    if (t >= rawTable.length) {\n      throw new Error('type index out of range');\n    }\n    return table[t];\n  }\n  function buildType(entry: [IDLTypeIds, any]): Type {\n    switch (entry[0]) {\n      case IDLTypeIds.Vector: {\n        const ty = getType(entry[1]);\n        return Vec(ty);\n      }\n      case IDLTypeIds.Opt: {\n        const ty = getType(entry[1]);\n        return Opt(ty);\n      }\n      case IDLTypeIds.Record: {\n        const fields: Record<string, Type> = {};\n        for (const [hash, ty] of entry[1]) {\n          const name = `_${hash}_`;\n          fields[name] = getType(ty);\n        }\n        const record = Record(fields);\n        const tuple = record.tryAsTuple();\n        if (Array.isArray(tuple)) {\n          return Tuple(...tuple);\n        } else {\n          return record;\n        }\n      }\n      case IDLTypeIds.Variant: {\n        const fields: Record<string, Type> = {};\n        for (const [hash, ty] of entry[1]) {\n          const name = `_${hash}_`;\n          fields[name] = getType(ty);\n        }\n        return Variant(fields);\n      }\n      case IDLTypeIds.Func: {\n        const [args, returnValues, annotations] = entry[1];\n        return Func(\n          args.map((t: number) => getType(t)),\n          returnValues.map((t: number) => getType(t)),\n          annotations,\n        );\n      }\n      case IDLTypeIds.Service: {\n        const rec: Record<string, FuncClass> = {};\n        const methods = entry[1] as [[string, number]];\n        for (const [name, typeRef] of methods) {\n          let type: Type | undefined = getType(typeRef);\n\n          if (type instanceof RecClass) {\n            // unpack reference type\n            type = type.getType();\n          }\n          if (!(type instanceof FuncClass)) {\n            throw new Error('Illegal service definition: services can only contain functions');\n          }\n          rec[name] = type;\n        }\n        return Service(rec);\n      }\n      default:\n        throw new Error('Illegal op_code: ' + entry[0]);\n    }\n  }\n\n  rawTable.forEach((entry, i) => {\n    // Process function type first, so that we can construct the correct service type\n    if (entry[0] === IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n  rawTable.forEach((entry, i) => {\n    if (entry[0] !== IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n\n  resetSubtypeCache();\n  const types = rawTypes.map(t => getType(t));\n  try {\n    const output = retTypes.map((t, i) => {\n      return t.decodeValue(b, types[i]);\n    });\n\n    // skip unused values\n    for (let ind = retTypes.length; ind < types.length; ind++) {\n      types[ind].decodeValue(b, types[ind]);\n    }\n\n    if (b.byteLength > 0) {\n      throw new Error('decode: Left-over bytes');\n    }\n\n    return output;\n  } finally {\n    resetSubtypeCache();\n  }\n}\n\n/**\n * An Interface Factory, normally provided by a Candid code generation.\n */\nexport type InterfaceFactory = (idl: {\n  IDL: {\n    Empty: EmptyClass;\n    Reserved: ReservedClass;\n    Unknown: UnknownClass;\n    Bool: BoolClass;\n    Null: NullClass;\n    Text: TextClass;\n    Int: IntClass;\n    Nat: NatClass;\n\n    Float32: FloatClass;\n    Float64: FloatClass;\n\n    Int8: FixedIntClass;\n    Int16: FixedIntClass;\n    Int32: FixedIntClass;\n    Int64: FixedIntClass;\n\n    Nat8: FixedNatClass;\n    Nat16: FixedNatClass;\n    Nat32: FixedNatClass;\n    Nat64: FixedNatClass;\n\n    Principal: PrincipalClass;\n\n    Tuple: typeof Tuple;\n    Vec: typeof Vec;\n    Opt: typeof Opt;\n    Record: typeof Record;\n    Variant: typeof Variant;\n    Rec: typeof Rec;\n    Func: typeof Func;\n\n    Service(t: Record<string, FuncClass>): ServiceClass;\n  };\n}) => ServiceClass;\n\n// Export Types instances.\nexport const Empty = new EmptyClass();\nexport const Reserved = new ReservedClass();\n/**\n * Client-only type for deserializing unknown data. Not supported by Candid, and its use is discouraged.\n */\nexport const Unknown = new UnknownClass();\nexport const Bool = new BoolClass();\nexport const Null = new NullClass();\nexport const Text = new TextClass();\nexport const Int = new IntClass();\nexport const Nat = new NatClass();\n\nexport const Float32 = new FloatClass(32);\nexport const Float64 = new FloatClass(64);\n\nexport const Int8 = new FixedIntClass(8);\nexport const Int16 = new FixedIntClass(16);\nexport const Int32 = new FixedIntClass(32);\nexport const Int64 = new FixedIntClass(64);\n\nexport const Nat8 = new FixedNatClass(8);\nexport const Nat16 = new FixedNatClass(16);\nexport const Nat32 = new FixedNatClass(32);\nexport const Nat64 = new FixedNatClass(64);\n\nexport const Principal = new PrincipalClass();\n\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nexport function Tuple<T extends any[]>(...types: T): TupleClass<T> {\n  return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nexport function Vec<T>(t: Type<T>): VecClass<T> {\n  return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nexport function Opt<T>(t: Type<T>): OptClass<T> {\n  return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nexport function Record(t: Record<string, Type>): RecordClass {\n  return new RecordClass(t);\n}\n\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nexport function Variant(fields: Record<string, Type>): VariantClass {\n  return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nexport function Rec(): RecClass {\n  return new RecClass();\n}\n\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nexport function Func(args: Type[], ret: Type[], annotations: string[] = []): FuncClass {\n  return new FuncClass(args, ret, annotations);\n}\n\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nexport function Service(t: Record<string, FuncClass>): ServiceClass {\n  return new ServiceClass(t);\n}\n\n/**\n * The list of relations between types we assume to hold. Uses the types .name property as key\n */\nclass Relations {\n  private rels: Map<string, Map<string, boolean>>;\n\n  constructor(relations = new Map()) {\n    this.rels = relations;\n  }\n\n  copy(): Relations {\n    const copy = new Map();\n    for (const [key, value] of this.rels.entries()) {\n      const valCopy = new Map(value);\n      copy.set(key, valCopy);\n    }\n    return new Relations(copy);\n  }\n\n  /// Returns whether we know for sure that a relation holds or doesn't (`true` or `false`), or\n  /// if we don't know yet (`undefined`)\n  known(t1: Type, t2: Type): boolean | undefined {\n    return this.rels.get(t1.name)?.get(t2.name);\n  }\n\n  addNegative(t1: Type, t2: Type) {\n    this.addNames(t1.name, t2.name, false);\n  }\n\n  add(t1: Type, t2: Type) {\n    this.addNames(t1.name, t2.name, true);\n  }\n\n  display(): string {\n    let result = '';\n    for (const [t1, v] of this.rels) {\n      for (const [t2, known] of v) {\n        const subty = known ? ':<' : '!<:';\n        result += `${t1} ${subty} ${t2}\\n`;\n      }\n    }\n    return result;\n  }\n\n  private addNames(t1: string, t2: string, isSubtype: boolean) {\n    const t1Map = this.rels.get(t1);\n    if (t1Map == undefined) {\n      const newMap = new Map();\n      newMap.set(t2, isSubtype);\n      this.rels.set(t1, newMap);\n    } else {\n      t1Map.set(t2, isSubtype);\n    }\n  }\n}\n\n/// `subtypeCache` holds subtyping relations we've previously computed while decoding a message\nlet subtypeCache: Relations = new Relations();\n\n/** Resets the global subtyping cache */\nexport function resetSubtypeCache() {\n  subtypeCache = new Relations();\n}\n\nfunction eqFunctionAnnotations(t1: FuncClass, t2: FuncClass): boolean {\n  const t1Annotations = new Set(t1.annotations);\n  const t2Annotations = new Set(t2.annotations);\n  if (t1Annotations.size !== t2Annotations.size) {\n    return false;\n  }\n  for (const a of t1Annotations) {\n    if (!t2Annotations.has(a)) return false;\n  }\n  return true;\n}\n\nfunction canBeOmmitted(t: Type) {\n  return t instanceof OptClass || t instanceof NullClass || t instanceof ReservedClass;\n}\n\n/**\n * Subtyping on Candid types t1 <: t2 (Exported for testing)\n * @param t1 The potential subtype\n * @param t2 The potential supertype\n */\nexport function subtype(t1: Type, t2: Type): boolean {\n  const relations = subtypeCache.copy();\n  const isSubtype = subtype_(relations, t1, t2);\n  if (isSubtype) {\n    subtypeCache.add(t1, t2);\n  } else {\n    subtypeCache.addNegative(t1, t2);\n  }\n  return isSubtype;\n}\n\nfunction subtype_(relations: Relations, t1: Type, t2: Type): boolean {\n  if (t1.name === t2.name) return true;\n  const known = relations.known(t1, t2);\n  if (known !== undefined) return known;\n  relations.add(t1, t2);\n\n  if (t2 instanceof ReservedClass) return true;\n  if (t1 instanceof EmptyClass) return true;\n  if (t1 instanceof NatClass && t2 instanceof IntClass) return true;\n  if (t1 instanceof VecClass && t2 instanceof VecClass)\n    return subtype_(relations, t1._type, t2._type);\n  if (t2 instanceof OptClass) return true;\n  if (t1 instanceof RecordClass && t2 instanceof RecordClass) {\n    const t1Object = t1.fieldsAsObject;\n    for (const [label, ty2] of t2._fields) {\n      const ty1 = t1Object[idlLabelToId(label)];\n      if (!ty1) {\n        if (!canBeOmmitted(ty2)) return false;\n      } else {\n        if (!subtype_(relations, ty1, ty2)) return false;\n      }\n    }\n    return true;\n  }\n\n  if (t1 instanceof FuncClass && t2 instanceof FuncClass) {\n    if (!eqFunctionAnnotations(t1, t2)) return false;\n    for (let i = 0; i < t1.argTypes.length; i++) {\n      const argTy1 = t1.argTypes[i];\n      if (i < t2.argTypes.length) {\n        if (!subtype_(relations, t2.argTypes[i], argTy1)) return false;\n      } else {\n        if (!canBeOmmitted(argTy1)) return false;\n      }\n    }\n    for (let i = 0; i < t2.retTypes.length; i++) {\n      const retTy2 = t2.retTypes[i];\n      if (i < t1.retTypes.length) {\n        if (!subtype_(relations, t1.retTypes[i], retTy2)) return false;\n      } else {\n        if (!canBeOmmitted(retTy2)) return false;\n      }\n    }\n    return true;\n  }\n\n  if (t1 instanceof VariantClass && t2 instanceof VariantClass) {\n    const t2Object = t2.alternativesAsObject;\n    for (const [label, ty1] of t1._fields) {\n      const ty2 = t2Object[idlLabelToId(label)];\n      if (!ty2) return false;\n      if (!subtype_(relations, ty1, ty2)) return false;\n    }\n    return true;\n  }\n\n  if (t1 instanceof ServiceClass && t2 instanceof ServiceClass) {\n    const t1Object = t1.fieldsAsObject();\n    for (const [name, ty2] of t2._fields) {\n      const ty1 = t1Object[name];\n      if (!ty1) return false;\n      if (!subtype_(relations, ty1, ty2)) return false;\n    }\n    return true;\n  }\n\n  if (t1 instanceof RecClass) {\n    return subtype_(relations, t1.getType()!, t2);\n  }\n  if (t2 instanceof RecClass) {\n    return subtype_(relations, t1, t2.getType()!);\n  }\n  return false;\n}\n"]}