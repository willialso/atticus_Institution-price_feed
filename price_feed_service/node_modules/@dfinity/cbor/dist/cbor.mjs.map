{"version":3,"file":"cbor.mjs","sources":["../src/decode/decoding-error.ts","../src/cbor-value.ts","../src/util/constants.ts","../src/util/nil.ts","../src/util/typed-array.ts","../src/decode/decode.ts","../src/encode/encoding-error.ts","../src/encode/encode.ts"],"sourcesContent":["export class DecodingError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DecodingError';\n  }\n}\n","export type CborValue<T = any> = ReplacedCborValue<T> | T;\n\nexport type ReplacedCborValue<T = any> =\n  | CborNumber\n  | string\n  | ArrayBuffer\n  | Uint8Array\n  | CborValue<T>[]\n  | CborMap<T>\n  | CborSimple;\n\n/**\n * The tag number `55799`, the self-described tag for CBOR.\n * The serialization of this tag's head is `0xd9d9f7`.\n * @see {@link https://www.rfc-editor.org/rfc/rfc8949.html#section-3.4.6}\n */\nexport const CBOR_SELF_DESCRIBED_TAG = 55799;\n\nexport type CborNumber = number | bigint;\n\nexport const CBOR_STOP_CODE = Symbol('CBOR_STOP_CODE');\n\nexport type CborSimple = boolean | null | undefined | typeof CBOR_STOP_CODE;\n\nexport enum CborSimpleType {\n  False = 0x14,\n  True = 0x15,\n  Null = 0x16,\n  Undefined = 0x17,\n  Break = 0x1f,\n}\n\nexport type CborMap<T = any> =\n  | {\n      [key: string]: CborValue<T>;\n    }\n  | {\n      [key: string | number]: CborValue<T>;\n    }\n  | {\n      [key: string | symbol]: CborValue<T>;\n    }\n  | {\n      [key: string | number | symbol]: CborValue<T>;\n    };\n\nexport enum CborMajorType {\n  UnsignedInteger = 0,\n  NegativeInteger = 1,\n  ByteString = 2,\n  TextString = 3,\n  Array = 4,\n  Map = 5,\n  Tag = 6,\n  Simple = 7,\n}\n\nexport const TOKEN_VALUE_MAX = 0x17;\nexport const ONE_BYTE_MAX = 0xff;\nexport const TWO_BYTES_MAX = 0xffff;\nexport const FOUR_BYTES_MAX = 0xffffffff;\n/**\n * The maximum value that can be encoded in 8 bytes: `18446744073709551615n`.\n */\nexport const EIGHT_BYTES_MAX = BigInt('0xffffffffffffffff');\n\nexport enum CborMinorType {\n  Value = 23,\n  OneByte = 24,\n  TwoBytes = 25,\n  FourBytes = 26,\n  EightBytes = 27,\n  Indefinite = 31,\n}\n","export const IS_LITTLE_ENDIAN = false;\n","export function isNil<T>(\n  value: T | null | undefined,\n): value is null | undefined {\n  return value === null || value === undefined;\n}\n\nexport function isNotNil<T>(value: T | null | undefined): value is T {\n  return !isNil(value);\n}\n","export function resizeUint8Array(\n  array: Uint8Array,\n  newSize: number,\n): Uint8Array {\n  const newArray = new Uint8Array(newSize);\n  newArray.set(array);\n  return newArray;\n}\n","import {\n  CBOR_SELF_DESCRIBED_TAG,\n  CBOR_STOP_CODE,\n  CborMajorType,\n  CborMap,\n  CborMinorType,\n  CborNumber,\n  CborSimple,\n  CborSimpleType,\n  CborValue,\n} from '../cbor-value';\nimport { IS_LITTLE_ENDIAN, isNil } from '../util';\nimport { DecodingError } from './decoding-error';\n\nconst textDecoder = new TextDecoder();\n\nfunction decodeMajorType(firstByte: number): CborMajorType {\n  return (firstByte & 0b1110_0000) >> 5;\n}\n\nfunction decodeInfo(firstByte: number): number {\n  return firstByte & 0b0001_1111;\n}\n\nlet cborBytes = new Uint8Array();\nlet dataView: DataView | undefined;\nlet bytesOffset = 0;\n\n/**\n * A function that can be used to manipulate the decoded value.\n * See {@link decode} for more information.\n * @param value - The value to manipulate.\n * @param key - The current key in a map, or the current stringified index in an array.\n * @returns The manipulated value.\n */\nexport type Reviver<K extends CborValue = CborValue> = (\n  value: K,\n  key?: K extends CborValue ? string : keyof K,\n) => [K] extends [never] ? CborValue : K;\n\n/**\n * Decodes a CBOR byte array into a value.\n * See {@link Reviver} for more information.\n * @param input - The CBOR byte array to decode.\n * @param reviver - A function that can be used to manipulate the decoded value.\n * @returns The decoded value.\n *\n * @example Simple\n * ```ts\n * const value = true;\n * const encoded = encode(value); // returns `Uint8Array [245]` (which is \"F5\" in hex)\n * const decoded = decode(encoded); // returns `true`\n * ```\n *\n * @example Reviver\n * ```ts\n * const bytes = ...; // Uint8Array corresponding to the CBOR encoding of `{ a: 1, b: 2 }`\n * const reviver: Reviver = val => (typeof val === 'number' ? val * 2 : val);\n * decode(bytes, reviver); // returns `{ a: 2, b: 4 }`\n * ```\n */\nexport function decode<T extends CborValue = CborValue>(\n  input: Uint8Array,\n  reviver?: Reviver<T>,\n): T {\n  cborBytes = input;\n  bytesOffset = 0;\n\n  const decodedItem = decodeItem(reviver as Reviver | undefined) as T;\n  return (reviver?.(decodedItem as T) ?? decodedItem) as T;\n}\n\nfunction decodeItem(reviver?: Reviver): CborValue {\n  const [majorType, info] = decodeNextByte();\n\n  switch (majorType) {\n    case CborMajorType.UnsignedInteger:\n      return decodeUnsignedInteger(info);\n\n    case CborMajorType.NegativeInteger:\n      return decodeNegativeInteger(info);\n\n    case CborMajorType.ByteString:\n      return decodeByteString(info);\n\n    case CborMajorType.TextString:\n      return decodeTextString(info);\n\n    case CborMajorType.Array:\n      return decodeArray(info, reviver);\n\n    case CborMajorType.Map:\n      return decodeMap(info, reviver);\n\n    case CborMajorType.Tag:\n      return decodeTag(info, reviver);\n\n    case CborMajorType.Simple:\n      return decodeSimple(info);\n  }\n\n  throw new DecodingError(`Unsupported major type: ${majorType}`);\n}\n\nfunction decodeNextByte(): [CborMajorType, number] {\n  const firstByte = cborBytes.at(bytesOffset);\n  if (isNil(firstByte)) {\n    throw new DecodingError('Provided CBOR data is empty');\n  }\n\n  const majorType = decodeMajorType(firstByte);\n  const info = decodeInfo(firstByte);\n\n  bytesOffset++;\n  return [majorType, info];\n}\n\nfunction decodeArray(info: number, reviver?: Reviver): CborValue[] {\n  const arrayLength = decodeUnsignedInteger(info);\n\n  if (arrayLength === Infinity) {\n    const values: CborValue[] = [];\n    let decodedItem = decodeItem(reviver);\n\n    while (decodedItem !== CBOR_STOP_CODE) {\n      values.push(reviver?.(decodedItem) ?? decodedItem);\n      decodedItem = decodeItem(reviver);\n    }\n\n    return values;\n  }\n\n  const values = new Array<CborValue>(arrayLength);\n  for (let i = 0; i < arrayLength; i++) {\n    const decodedItem = decodeItem(reviver);\n    values[i] = reviver?.(decodedItem) ?? decodedItem;\n  }\n  return values;\n}\n\nfunction decodeSimple(info: number): CborSimple {\n  switch (info) {\n    case CborSimpleType.False: {\n      return false;\n    }\n    case CborSimpleType.True: {\n      return true;\n    }\n    case CborSimpleType.Null: {\n      return null;\n    }\n    case CborSimpleType.Undefined: {\n      return undefined;\n    }\n    case CborSimpleType.Break: {\n      return CBOR_STOP_CODE;\n    }\n  }\n\n  throw new DecodingError(`Unrecognized simple type: ${info.toString(2)}`);\n}\n\nfunction decodeMap(info: number, reviver?: Reviver): CborMap {\n  const mapLength = decodeUnsignedInteger(info);\n  const map: CborMap = {};\n\n  if (mapLength === Infinity) {\n    let [majorType, info] = decodeNextByte();\n\n    while (\n      majorType !== CborMajorType.Simple &&\n      info !== CborSimpleType.Break\n    ) {\n      const key = decodeTextString(info);\n      const decodedItem = decodeItem(reviver);\n      map[key] = reviver?.(decodedItem, key) ?? decodedItem;\n\n      [majorType, info] = decodeNextByte();\n    }\n\n    return map;\n  }\n\n  for (let i = 0; i < mapLength; i++) {\n    const [majorType, info] = decodeNextByte();\n\n    if (majorType !== CborMajorType.TextString) {\n      throw new DecodingError('Map keys must be text strings');\n    }\n\n    const key = decodeTextString(info);\n    const decodedItem = decodeItem(reviver);\n    map[key] = reviver?.(decodedItem, key) ?? decodedItem;\n  }\n\n  return map;\n}\n\nfunction decodeUnsignedInteger(info: number): CborNumber {\n  if (info <= CborMinorType.Value) {\n    return info;\n  }\n\n  dataView = new DataView(cborBytes.buffer, cborBytes.byteOffset + bytesOffset);\n  switch (info) {\n    case CborMinorType.OneByte:\n      bytesOffset++;\n      return dataView.getUint8(0);\n\n    case CborMinorType.TwoBytes:\n      bytesOffset += 2;\n      return dataView.getUint16(0, IS_LITTLE_ENDIAN);\n\n    case CborMinorType.FourBytes:\n      bytesOffset += 4;\n      return dataView.getUint32(0, IS_LITTLE_ENDIAN);\n\n    case CborMinorType.EightBytes:\n      bytesOffset += 8;\n      return dataView.getBigUint64(0, IS_LITTLE_ENDIAN);\n\n    case CborMinorType.Indefinite:\n      return Infinity;\n\n    default:\n      throw new DecodingError(`Unsupported integer info: ${info.toString(2)}`);\n  }\n}\n\nfunction decodeNegativeInteger(info: number): CborNumber {\n  const value = decodeUnsignedInteger(info);\n  const negativeValue = typeof value === 'number' ? -1 - value : -1n - value;\n\n  return negativeValue;\n}\n\nfunction decodeByteString(info: number): Uint8Array {\n  const byteLength = decodeUnsignedInteger(info);\n  if (byteLength > Number.MAX_SAFE_INTEGER) {\n    throw new DecodingError('Byte length is too large');\n  }\n\n  const safeByteLength = Number(byteLength);\n  bytesOffset += safeByteLength;\n  return cborBytes.slice(bytesOffset - safeByteLength, bytesOffset);\n}\n\nfunction decodeTextString(info: number): string {\n  const bytes = decodeByteString(info);\n\n  return textDecoder.decode(bytes);\n}\n\nfunction decodeTag(info: number, reviver?: Reviver): CborValue {\n  const value = decodeUnsignedInteger(info);\n\n  if (value === CBOR_SELF_DESCRIBED_TAG) {\n    return decodeItem(reviver);\n  }\n\n  throw new DecodingError(`Unsupported tag: ${value}.`);\n}\n","export class EncodingError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'SerializationError';\n  }\n}\n","import {\n  CborMajorType,\n  CborMap,\n  CborMinorType,\n  CborNumber,\n  CborSimple,\n  CborSimpleType,\n  CborValue,\n  ReplacedCborValue,\n  EIGHT_BYTES_MAX,\n  FOUR_BYTES_MAX,\n  ONE_BYTE_MAX,\n  TOKEN_VALUE_MAX,\n  TWO_BYTES_MAX,\n  CBOR_SELF_DESCRIBED_TAG,\n} from '../cbor-value';\nimport { EncodingError } from './encoding-error';\nimport { IS_LITTLE_ENDIAN, resizeUint8Array } from '../util';\n\nconst INITIAL_BUFFER_SIZE = 2 * 1_024;\nconst SAFE_BUFFER_END_OFFSET = 100;\n\nconst textEncoder = new TextEncoder();\n\nfunction encodeMajorType(majorType: CborMajorType): number {\n  return majorType << 5;\n}\n\nlet target = new Uint8Array(INITIAL_BUFFER_SIZE);\nlet targetView = new DataView(target.buffer);\nlet bytesOffset = 0;\nlet mapEntries: [string, CborValue][] = [];\n\n/**\n * A function that can be used to manipulate the input before it is encoded.\n * See {@link encode} for more information.\n * @param value - The value to manipulate.\n * @param key - The current key in a map, or the current stringified index in an array.\n * @returns The manipulated value.\n */\nexport type Replacer<T = any> = (\n  value: CborValue<T>,\n  key?: string,\n) => ReplacedCborValue<T>;\n\n/**\n * Encodes a value into a CBOR byte array.\n * @param value - The value to encode.\n * @param replacer - A function that can be used to manipulate the input before it is encoded.\n * @returns The encoded value.\n *\n * @example Simple\n * ```ts\n * const value = true;\n * const encoded = encode(value); // returns `Uint8Array [245]` (which is \"F5\" in hex)\n * ```\n *\n * @example Replacer\n * ```ts\n * const replacer: Replacer = val => (typeof val === 'number' ? val * 2 : val);\n * encode({ a: 1, b: 2 }, replacer); // returns the Uint8Array corresponding to the CBOR encoding of `{ a: 2, b: 4 }`\n * ```\n */\nexport function encode<T = any>(\n  value: CborValue<T>,\n  replacer?: Replacer<T>,\n): Uint8Array {\n  bytesOffset = 0;\n\n  const transformedValue = replacer?.(value) ?? value;\n  encodeItem(transformedValue, replacer);\n\n  return target.slice(0, bytesOffset);\n}\n\n/**\n * Encodes a value into a CBOR byte array (same as {@link encode}), but prepends the self-described CBOR tag (55799).\n * @param value - The value to encode.\n * @param replacer - A function that can be used to manipulate the input before it is encoded.\n * @returns The encoded value with the self-described CBOR tag.\n *\n * @example\n * ```ts\n * const value = true;\n * const encoded = encodeWithSelfDescribedTag(value); // returns the Uint8Array [217, 217, 247, 245] (which is \"D9D9F7F5\" in hex)\n * ```\n */\nexport function encodeWithSelfDescribedTag<T = any>(\n  value: CborValue<T>,\n  replacer?: Replacer<T>,\n): Uint8Array {\n  bytesOffset = 0;\n\n  const transformedValue = replacer?.(value) ?? value;\n  encodeTag(CBOR_SELF_DESCRIBED_TAG, transformedValue, replacer);\n\n  return target.slice(0, bytesOffset);\n}\n\nfunction encodeItem(item: CborValue, replacer?: Replacer): void {\n  if (bytesOffset > target.length - SAFE_BUFFER_END_OFFSET) {\n    target = resizeUint8Array(target, target.length * 2);\n    targetView = new DataView(target.buffer);\n  }\n\n  if (item === false || item === true || item === null || item === undefined) {\n    encodeSimple(item);\n    return;\n  }\n\n  if (typeof item === 'number' || typeof item === 'bigint') {\n    encodeNumber(item);\n    return;\n  }\n\n  if (typeof item === 'string') {\n    encodeTextString(item);\n    return;\n  }\n\n  if (item instanceof Uint8Array) {\n    encodeByteString(item);\n    return;\n  }\n\n  if (item instanceof ArrayBuffer) {\n    encodeByteString(new Uint8Array(item));\n    return;\n  }\n\n  if (Array.isArray(item)) {\n    encodeArray(item, replacer);\n    return;\n  }\n\n  if (typeof item === 'object') {\n    encodeMap(item, replacer);\n    return;\n  }\n\n  throw new EncodingError(`Unsupported type: ${typeof item}`);\n}\n\nfunction encodeArray(items: CborValue[], replacer?: Replacer): void {\n  encodeHeader(CborMajorType.Array, items.length);\n\n  items.forEach((item, i) => {\n    encodeItem(replacer?.(item, i.toString()) ?? item, replacer);\n  });\n}\n\nfunction encodeMap(map: CborMap, replacer?: Replacer): void {\n  mapEntries = Object.entries(map);\n\n  encodeHeader(CborMajorType.Map, mapEntries.length);\n\n  mapEntries.forEach(([key, value]) => {\n    encodeTextString(key);\n    encodeItem(replacer?.(value, key) ?? value, replacer);\n  });\n}\n\nfunction encodeHeader(majorType: CborMajorType, value: CborNumber): void {\n  if (value <= TOKEN_VALUE_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | Number(value),\n    );\n    return;\n  }\n\n  if (value <= ONE_BYTE_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | CborMinorType.OneByte,\n    );\n    targetView.setUint8(bytesOffset, Number(value));\n    bytesOffset += 1;\n    return;\n  }\n\n  if (value <= TWO_BYTES_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | CborMinorType.TwoBytes,\n    );\n    targetView.setUint16(bytesOffset, Number(value), IS_LITTLE_ENDIAN);\n    bytesOffset += 2;\n    return;\n  }\n\n  if (value <= FOUR_BYTES_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | CborMinorType.FourBytes,\n    );\n    targetView.setUint32(bytesOffset, Number(value), IS_LITTLE_ENDIAN);\n    bytesOffset += 4;\n    return;\n  }\n\n  if (value <= EIGHT_BYTES_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | CborMinorType.EightBytes,\n    );\n    targetView.setBigUint64(bytesOffset, BigInt(value), IS_LITTLE_ENDIAN);\n    bytesOffset += 8;\n    return;\n  }\n\n  throw new EncodingError(`Value too large to encode: ${value}`);\n}\n\nfunction encodeSimple(value: CborSimple): void {\n  encodeHeader(CborMajorType.Simple, mapSimple(value));\n}\n\nfunction mapSimple(value: CborSimple): CborSimpleType {\n  if (value === false) {\n    return CborSimpleType.False;\n  }\n\n  if (value === true) {\n    return CborSimpleType.True;\n  }\n\n  if (value === null) {\n    return CborSimpleType.Null;\n  }\n\n  if (value === undefined) {\n    return CborSimpleType.Undefined;\n  }\n\n  throw new EncodingError(`Unrecognized simple value: ${value.toString()}`);\n}\n\nfunction encodeBytes(majorType: CborMajorType, value: Uint8Array): void {\n  encodeHeader(majorType, value.length);\n\n  if (bytesOffset > target.length - value.length) {\n    target = resizeUint8Array(target, target.length + value.length);\n    targetView = new DataView(target.buffer);\n  }\n  target.set(value, bytesOffset);\n  bytesOffset += value.length;\n}\n\nfunction encodeInteger(majorType: CborMajorType, value: CborNumber): void {\n  encodeHeader(majorType, value);\n}\n\nfunction encodeUnsignedInteger(value: CborNumber): void {\n  encodeInteger(CborMajorType.UnsignedInteger, value);\n}\n\nfunction encodeNegativeInteger(value: CborNumber): void {\n  encodeInteger(\n    CborMajorType.NegativeInteger,\n    typeof value === 'bigint' ? -1n - value : -1 - value,\n  );\n}\n\nfunction encodeNumber(value: CborNumber): void {\n  value >= 0 ? encodeUnsignedInteger(value) : encodeNegativeInteger(value);\n}\n\nfunction encodeTextString(value: string): void {\n  encodeBytes(CborMajorType.TextString, textEncoder.encode(value));\n}\n\nfunction encodeByteString(value: Uint8Array): void {\n  encodeBytes(CborMajorType.ByteString, value);\n}\n\nfunction encodeTag(tag: number, value: CborValue, replacer?: Replacer): void {\n  encodeHeader(CborMajorType.Tag, tag);\n  encodeItem(value, replacer);\n}\n"],"names":["DecodingError","message","CBOR_SELF_DESCRIBED_TAG","CBOR_STOP_CODE","CborSimpleType","CborMajorType","TOKEN_VALUE_MAX","ONE_BYTE_MAX","TWO_BYTES_MAX","FOUR_BYTES_MAX","EIGHT_BYTES_MAX","CborMinorType","IS_LITTLE_ENDIAN","isNil","value","resizeUint8Array","array","newSize","newArray","textDecoder","decodeMajorType","firstByte","decodeInfo","cborBytes","dataView","bytesOffset","decode","input","reviver","decodedItem","decodeItem","majorType","info","decodeNextByte","decodeUnsignedInteger","decodeNegativeInteger","decodeByteString","decodeTextString","decodeArray","decodeMap","decodeTag","decodeSimple","arrayLength","values","i","mapLength","map","key","byteLength","safeByteLength","bytes","EncodingError","INITIAL_BUFFER_SIZE","SAFE_BUFFER_END_OFFSET","textEncoder","encodeMajorType","target","targetView","mapEntries","encode","replacer","transformedValue","encodeItem","encodeWithSelfDescribedTag","encodeTag","item","encodeSimple","encodeNumber","encodeTextString","encodeByteString","encodeArray","encodeMap","items","encodeHeader","mapSimple","encodeBytes","encodeInteger","encodeUnsignedInteger","encodeNegativeInteger","tag"],"mappings":"AAAO,MAAMA,UAAsB,MAAM;AAAA,EACvC,YAAYC,GAAiB;AAC3B,UAAMA,CAAO,GACb,KAAK,OAAO;AAAA,EAAA;AAEhB;ACWO,MAAMC,IAA0B,OAI1BC,IAAiB,OAAO,gBAAgB;AAIzC,IAAAC,sBAAAA,OACVA,EAAAA,EAAA,QAAQ,EAAR,IAAA,SACAA,EAAAA,EAAA,OAAO,EAAP,IAAA,QACAA,EAAAA,EAAA,OAAO,EAAP,IAAA,QACAA,EAAAA,EAAA,YAAY,EAAZ,IAAA,aACAA,EAAAA,EAAA,QAAQ,EAAR,IAAA,SALUA,IAAAA,KAAA,CAAA,CAAA,GAsBAC,sBAAAA,OACVA,EAAAA,EAAA,kBAAkB,CAAlB,IAAA,mBACAA,EAAAA,EAAA,kBAAkB,CAAlB,IAAA,mBACAA,EAAAA,EAAA,aAAa,CAAb,IAAA,cACAA,EAAAA,EAAA,aAAa,CAAb,IAAA,cACAA,EAAAA,EAAA,QAAQ,CAAR,IAAA,SACAA,EAAAA,EAAA,MAAM,CAAN,IAAA,OACAA,EAAAA,EAAA,MAAM,CAAN,IAAA,OACAA,EAAAA,EAAA,SAAS,CAAT,IAAA,UARUA,IAAAA,KAAA,CAAA,CAAA;AAWL,MAAMC,IAAkB,IAClBC,IAAe,KACfC,IAAgB,OAChBC,IAAiB,YAIjBC,IAAkB,OAAO,oBAAoB;AAE9C,IAAAC,sBAAAA,OACVA,EAAAA,EAAA,QAAQ,EAAR,IAAA,SACAA,EAAAA,EAAA,UAAU,EAAV,IAAA,WACAA,EAAAA,EAAA,WAAW,EAAX,IAAA,YACAA,EAAAA,EAAA,YAAY,EAAZ,IAAA,aACAA,EAAAA,EAAA,aAAa,EAAb,IAAA,cACAA,EAAAA,EAAA,aAAa,EAAb,IAAA,cANUA,IAAAA,KAAA,CAAA,CAAA;AClEL,MAAMC,IAAmB;ACAzB,SAASC,EACdC,GAC2B;AACpB,SAAAA,KAAU;AACnB;ACJgB,SAAAC,EACdC,GACAC,GACY;AACN,QAAAC,IAAW,IAAI,WAAWD,CAAO;AACvC,SAAAC,EAAS,IAAIF,CAAK,GACXE;AACT;ACOA,MAAMC,IAAc,IAAI,YAAY;AAEpC,SAASC,EAAgBC,GAAkC;AACzD,UAAQA,IAAY,QAAgB;AACtC;AAEA,SAASC,EAAWD,GAA2B;AAC7C,SAAOA,IAAY;AACrB;AAEA,IAAIE,IAAY,IAAI,WAAW,GAC3BC,GACAC,IAAc;AAmCF,SAAAC,GACdC,GACAC,GACG;AACS,EAAAL,IAAAI,GACEF,IAAA;AAER,QAAAI,IAAcC,EAAWF,CAA8B;AACrD,UAAAA,KAAA,gBAAAA,EAAUC,OAAqBA;AACzC;AAEA,SAASC,EAAWF,GAA8B;AAChD,QAAM,CAACG,GAAWC,CAAI,IAAIC,EAAe;AAEzC,UAAQF,GAAW;AAAA,IACjB,KAAK1B,EAAc;AACjB,aAAO6B,EAAsBF,CAAI;AAAA,IAEnC,KAAK3B,EAAc;AACjB,aAAO8B,EAAsBH,CAAI;AAAA,IAEnC,KAAK3B,EAAc;AACjB,aAAO+B,EAAiBJ,CAAI;AAAA,IAE9B,KAAK3B,EAAc;AACjB,aAAOgC,EAAiBL,CAAI;AAAA,IAE9B,KAAK3B,EAAc;AACV,aAAAiC,EAAYN,GAAMJ,CAAO;AAAA,IAElC,KAAKvB,EAAc;AACV,aAAAkC,EAAUP,GAAMJ,CAAO;AAAA,IAEhC,KAAKvB,EAAc;AACV,aAAAmC,EAAUR,GAAMJ,CAAO;AAAA,IAEhC,KAAKvB,EAAc;AACjB,aAAOoC,EAAaT,CAAI;AAAA,EAAA;AAG5B,QAAM,IAAIhC,EAAc,2BAA2B+B,CAAS,EAAE;AAChE;AAEA,SAASE,IAA0C;AAC3C,QAAAZ,IAAYE,EAAU,GAAGE,CAAW;AACtC,MAAAZ,EAAMQ,CAAS;AACX,UAAA,IAAIrB,EAAc,6BAA6B;AAGjD,QAAA+B,IAAYX,EAAgBC,CAAS,GACrCW,IAAOV,EAAWD,CAAS;AAEjCI,SAAAA,KACO,CAACM,GAAWC,CAAI;AACzB;AAEA,SAASM,EAAYN,GAAcJ,GAAgC;AAC3D,QAAAc,IAAcR,EAAsBF,CAAI;AAE9C,MAAIU,MAAgB,OAAU;AAC5B,UAAMC,IAAsB,CAAC;AACzB,QAAAd,IAAcC,EAAWF,CAAO;AAEpC,WAAOC,MAAgB1B;AACrBwC,MAAAA,EAAO,MAAKf,KAAA,gBAAAA,EAAUC,OAAgBA,CAAW,GACjDA,IAAcC,EAAWF,CAAO;AAG3Be,WAAAA;AAAAA,EAAA;AAGH,QAAAA,IAAS,IAAI,MAAiBD,CAAW;AAC/C,WAASE,IAAI,GAAGA,IAAIF,GAAaE,KAAK;AAC9B,UAAAf,IAAcC,EAAWF,CAAO;AACtC,IAAAe,EAAOC,CAAC,KAAIhB,KAAA,gBAAAA,EAAUC,OAAgBA;AAAA,EAAA;AAEjC,SAAAc;AACT;AAEA,SAASF,EAAaT,GAA0B;AAC9C,UAAQA,GAAM;AAAA,IACZ,KAAK5B,EAAe;AACX,aAAA;AAAA,IAET,KAAKA,EAAe;AACX,aAAA;AAAA,IAET,KAAKA,EAAe;AACX,aAAA;AAAA,IAET,KAAKA,EAAe;AACX;AAAA,IAET,KAAKA,EAAe;AACX,aAAAD;AAAA,EACT;AAGF,QAAM,IAAIH,EAAc,6BAA6BgC,EAAK,SAAS,CAAC,CAAC,EAAE;AACzE;AAEA,SAASO,EAAUP,GAAcJ,GAA4B;AACrD,QAAAiB,IAAYX,EAAsBF,CAAI,GACtCc,IAAe,CAAC;AAEtB,MAAID,MAAc,OAAU;AAC1B,QAAI,CAACd,GAAWC,CAAI,IAAIC,EAAe;AAEvC,WACEF,MAAc1B,EAAc,UAC5B2B,MAAS5B,EAAe,SACxB;AACM,YAAA2C,IAAMV,EAAiBL,CAAI,GAC3BH,IAAcC,EAAWF,CAAO;AACtC,MAAAkB,EAAIC,CAAG,KAAInB,KAAA,gBAAAA,EAAUC,GAAakB,OAAQlB,GAEzC,CAAAE,GAAWC,CAAI,IAAIC,EAAe;AAAA,IAAA;AAG9B,WAAAa;AAAA,EAAA;AAGT,WAASF,IAAI,GAAGA,IAAIC,GAAWD,KAAK;AAClC,UAAM,CAACb,GAAWC,CAAI,IAAIC,EAAe;AAErC,QAAAF,MAAc1B,EAAc;AACxB,YAAA,IAAIL,EAAc,+BAA+B;AAGnD,UAAA+C,IAAMV,EAAiBL,CAAI,GAC3BH,IAAcC,EAAWF,CAAO;AACtC,IAAAkB,EAAIC,CAAG,KAAInB,KAAA,gBAAAA,EAAUC,GAAakB,OAAQlB;AAAA,EAAA;AAGrC,SAAAiB;AACT;AAEA,SAASZ,EAAsBF,GAA0B;AACnD,MAAAA,KAAQrB,EAAc;AACjB,WAAAqB;AAIT,UADAR,IAAW,IAAI,SAASD,EAAU,QAAQA,EAAU,aAAaE,CAAW,GACpEO,GAAM;AAAA,IACZ,KAAKrB,EAAc;AACjBc,aAAAA,KACOD,EAAS,SAAS,CAAC;AAAA,IAE5B,KAAKb,EAAc;AACFc,aAAAA,KAAA,GACRD,EAAS,UAAU,GAAGZ,CAAgB;AAAA,IAE/C,KAAKD,EAAc;AACFc,aAAAA,KAAA,GACRD,EAAS,UAAU,GAAGZ,CAAgB;AAAA,IAE/C,KAAKD,EAAc;AACFc,aAAAA,KAAA,GACRD,EAAS,aAAa,GAAGZ,CAAgB;AAAA,IAElD,KAAKD,EAAc;AACV,aAAA;AAAA,IAET;AACE,YAAM,IAAIX,EAAc,6BAA6BgC,EAAK,SAAS,CAAC,CAAC,EAAE;AAAA,EAAA;AAE7E;AAEA,SAASG,EAAsBH,GAA0B;AACjD,QAAAlB,IAAQoB,EAAsBF,CAAI;AAGjC,SAFe,OAAOlB,KAAU,WAAW,KAAKA,IAAQ,CAAC,KAAKA;AAGvE;AAEA,SAASsB,EAAiBJ,GAA0B;AAC5C,QAAAgB,IAAad,EAAsBF,CAAI;AACzC,MAAAgB,IAAa,OAAO;AAChB,UAAA,IAAIhD,EAAc,0BAA0B;AAG9C,QAAAiD,IAAiB,OAAOD,CAAU;AACzBvB,SAAAA,KAAAwB,GACR1B,EAAU,MAAME,IAAcwB,GAAgBxB,CAAW;AAClE;AAEA,SAASY,EAAiBL,GAAsB;AACxC,QAAAkB,IAAQd,EAAiBJ,CAAI;AAE5B,SAAAb,EAAY,OAAO+B,CAAK;AACjC;AAEA,SAASV,EAAUR,GAAcJ,GAA8B;AACvD,QAAAd,IAAQoB,EAAsBF,CAAI;AAExC,MAAIlB,MAAUZ;AACZ,WAAO4B,EAAWF,CAAO;AAG3B,QAAM,IAAI5B,EAAc,oBAAoBc,CAAK,GAAG;AACtD;ACrQO,MAAMqC,UAAsB,MAAM;AAAA,EACvC,YAAYlD,GAAiB;AAC3B,UAAMA,CAAO,GACb,KAAK,OAAO;AAAA,EAAA;AAEhB;ACcA,MAAMmD,IAAsB,IAAI,MAC1BC,IAAyB,KAEzBC,IAAc,IAAI,YAAY;AAEpC,SAASC,EAAgBxB,GAAkC;AACzD,SAAOA,KAAa;AACtB;AAEA,IAAIyB,IAAS,IAAI,WAAWJ,CAAmB,GAC3CK,IAAa,IAAI,SAASD,EAAO,MAAM,GACvC/B,IAAc,GACdiC,IAAoC,CAAC;AAgCzB,SAAAC,GACd7C,GACA8C,GACY;AACE,EAAAnC,IAAA;AAER,QAAAoC,KAAmBD,KAAA,gBAAAA,EAAW9C,OAAUA;AAC9C,SAAAgD,EAAWD,GAAkBD,CAAQ,GAE9BJ,EAAO,MAAM,GAAG/B,CAAW;AACpC;AAcgB,SAAAsC,GACdjD,GACA8C,GACY;AACE,EAAAnC,IAAA;AAER,QAAAoC,KAAmBD,KAAA,gBAAAA,EAAW9C,OAAUA;AACpC,SAAAkD,GAAA9D,GAAyB2D,GAAkBD,CAAQ,GAEtDJ,EAAO,MAAM,GAAG/B,CAAW;AACpC;AAEA,SAASqC,EAAWG,GAAiBL,GAA2B;AAM9D,MALInC,IAAc+B,EAAO,SAASH,MAChCG,IAASzC,EAAiByC,GAAQA,EAAO,SAAS,CAAC,GACtCC,IAAA,IAAI,SAASD,EAAO,MAAM,IAGrCS,MAAS,MAASA,MAAS,MAAQA,MAAS,QAAQA,MAAS,QAAW;AAC1E,IAAAC,GAAaD,CAAI;AACjB;AAAA,EAAA;AAGF,MAAI,OAAOA,KAAS,YAAY,OAAOA,KAAS,UAAU;AACxD,IAAAE,GAAaF,CAAI;AACjB;AAAA,EAAA;AAGE,MAAA,OAAOA,KAAS,UAAU;AAC5B,IAAAG,EAAiBH,CAAI;AACrB;AAAA,EAAA;AAGF,MAAIA,aAAgB,YAAY;AAC9B,IAAAI,EAAiBJ,CAAI;AACrB;AAAA,EAAA;AAGF,MAAIA,aAAgB,aAAa;AACd,IAAAI,EAAA,IAAI,WAAWJ,CAAI,CAAC;AACrC;AAAA,EAAA;AAGE,MAAA,MAAM,QAAQA,CAAI,GAAG;AACvB,IAAAK,GAAYL,GAAML,CAAQ;AAC1B;AAAA,EAAA;AAGE,MAAA,OAAOK,KAAS,UAAU;AAC5B,IAAAM,GAAUN,GAAML,CAAQ;AACxB;AAAA,EAAA;AAGF,QAAM,IAAIT,EAAc,qBAAqB,OAAOc,CAAI,EAAE;AAC5D;AAEA,SAASK,GAAYE,GAAoBZ,GAA2B;AACrD,EAAAa,EAAApE,EAAc,OAAOmE,EAAM,MAAM,GAExCA,EAAA,QAAQ,CAACP,GAAM,MAAM;AACzB,IAAAH,GAAWF,KAAA,gBAAAA,EAAWK,GAAM,EAAE,gBAAeA,GAAML,CAAQ;AAAA,EAAA,CAC5D;AACH;AAEA,SAASW,GAAUzB,GAAcc,GAA2B;AAC7C,EAAAF,IAAA,OAAO,QAAQZ,CAAG,GAElB2B,EAAApE,EAAc,KAAKqD,EAAW,MAAM,GAEjDA,EAAW,QAAQ,CAAC,CAACX,GAAKjC,CAAK,MAAM;AACnC,IAAAsD,EAAiBrB,CAAG,GACpBe,GAAWF,KAAA,gBAAAA,EAAW9C,GAAOiC,OAAQjC,GAAO8C,CAAQ;AAAA,EAAA,CACrD;AACH;AAEA,SAASa,EAAa1C,GAA0BjB,GAAyB;AACvE,MAAIA,KAASR,GAAiB;AACjB,IAAAmD,EAAA;AAAA,MACThC;AAAA,MACA8B,EAAgBxB,CAAS,IAAI,OAAOjB,CAAK;AAAA,IAC3C;AACA;AAAA,EAAA;AAGF,MAAIA,KAASP,GAAc;AACd,IAAAkD,EAAA;AAAA,MACThC;AAAA,MACA8B,EAAgBxB,CAAS,IAAIpB,EAAc;AAAA,IAC7C,GACA8C,EAAW,SAAShC,GAAa,OAAOX,CAAK,CAAC,GAC/BW,KAAA;AACf;AAAA,EAAA;AAGF,MAAIX,KAASN,GAAe;AACf,IAAAiD,EAAA;AAAA,MACThC;AAAA,MACA8B,EAAgBxB,CAAS,IAAIpB,EAAc;AAAA,IAC7C,GACA8C,EAAW,UAAUhC,GAAa,OAAOX,CAAK,GAAGF,CAAgB,GAClDa,KAAA;AACf;AAAA,EAAA;AAGF,MAAIX,KAASL,GAAgB;AAChB,IAAAgD,EAAA;AAAA,MACThC;AAAA,MACA8B,EAAgBxB,CAAS,IAAIpB,EAAc;AAAA,IAC7C,GACA8C,EAAW,UAAUhC,GAAa,OAAOX,CAAK,GAAGF,CAAgB,GAClDa,KAAA;AACf;AAAA,EAAA;AAGF,MAAIX,KAASJ,GAAiB;AACjB,IAAA+C,EAAA;AAAA,MACThC;AAAA,MACA8B,EAAgBxB,CAAS,IAAIpB,EAAc;AAAA,IAC7C,GACA8C,EAAW,aAAahC,GAAa,OAAOX,CAAK,GAAGF,CAAgB,GACrDa,KAAA;AACf;AAAA,EAAA;AAGF,QAAM,IAAI0B,EAAc,8BAA8BrC,CAAK,EAAE;AAC/D;AAEA,SAASoD,GAAapD,GAAyB;AAC7C,EAAA2D,EAAapE,EAAc,QAAQqE,GAAU5D,CAAK,CAAC;AACrD;AAEA,SAAS4D,GAAU5D,GAAmC;AACpD,MAAIA,MAAU;AACZ,WAAOV,EAAe;AAGxB,MAAIU,MAAU;AACZ,WAAOV,EAAe;AAGxB,MAAIU,MAAU;AACZ,WAAOV,EAAe;AAGxB,MAAIU,MAAU;AACZ,WAAOV,EAAe;AAGxB,QAAM,IAAI+C,EAAc,8BAA8BrC,EAAM,SAAU,CAAA,EAAE;AAC1E;AAEA,SAAS6D,EAAY5C,GAA0BjB,GAAyB;AACzD,EAAA2D,EAAA1C,GAAWjB,EAAM,MAAM,GAEhCW,IAAc+B,EAAO,SAAS1C,EAAM,WACtC0C,IAASzC,EAAiByC,GAAQA,EAAO,SAAS1C,EAAM,MAAM,GACjD2C,IAAA,IAAI,SAASD,EAAO,MAAM,IAElCA,EAAA,IAAI1C,GAAOW,CAAW,GAC7BA,KAAeX,EAAM;AACvB;AAEA,SAAS8D,EAAc7C,GAA0BjB,GAAyB;AACxE,EAAA2D,EAAa1C,GAAWjB,CAAK;AAC/B;AAEA,SAAS+D,GAAsB/D,GAAyB;AACxC,EAAA8D,EAAAvE,EAAc,iBAAiBS,CAAK;AACpD;AAEA,SAASgE,GAAsBhE,GAAyB;AACtD,EAAA8D;AAAA,IACEvE,EAAc;AAAA,IACd,OAAOS,KAAU,WAAW,CAAC,KAAKA,IAAQ,KAAKA;AAAA,EACjD;AACF;AAEA,SAASqD,GAAarD,GAAyB;AAC7C,EAAAA,KAAS,IAAI+D,GAAsB/D,CAAK,IAAIgE,GAAsBhE,CAAK;AACzE;AAEA,SAASsD,EAAiBtD,GAAqB;AAC7C,EAAA6D,EAAYtE,EAAc,YAAYiD,EAAY,OAAOxC,CAAK,CAAC;AACjE;AAEA,SAASuD,EAAiBvD,GAAyB;AACrC,EAAA6D,EAAAtE,EAAc,YAAYS,CAAK;AAC7C;AAEA,SAASkD,GAAUe,GAAajE,GAAkB8C,GAA2B;AAC9D,EAAAa,EAAApE,EAAc,KAAK0E,CAAG,GACnCjB,EAAWhD,GAAO8C,CAAQ;AAC5B;"}