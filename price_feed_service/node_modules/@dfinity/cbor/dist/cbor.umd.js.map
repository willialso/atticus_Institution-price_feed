{"version":3,"file":"cbor.umd.js","sources":["../src/decode/decoding-error.ts","../src/cbor-value.ts","../src/util/constants.ts","../src/util/nil.ts","../src/util/typed-array.ts","../src/decode/decode.ts","../src/encode/encoding-error.ts","../src/encode/encode.ts"],"sourcesContent":["export class DecodingError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DecodingError';\n  }\n}\n","export type CborValue<T = any> = ReplacedCborValue<T> | T;\n\nexport type ReplacedCborValue<T = any> =\n  | CborNumber\n  | string\n  | ArrayBuffer\n  | Uint8Array\n  | CborValue<T>[]\n  | CborMap<T>\n  | CborSimple;\n\n/**\n * The tag number `55799`, the self-described tag for CBOR.\n * The serialization of this tag's head is `0xd9d9f7`.\n * @see {@link https://www.rfc-editor.org/rfc/rfc8949.html#section-3.4.6}\n */\nexport const CBOR_SELF_DESCRIBED_TAG = 55799;\n\nexport type CborNumber = number | bigint;\n\nexport const CBOR_STOP_CODE = Symbol('CBOR_STOP_CODE');\n\nexport type CborSimple = boolean | null | undefined | typeof CBOR_STOP_CODE;\n\nexport enum CborSimpleType {\n  False = 0x14,\n  True = 0x15,\n  Null = 0x16,\n  Undefined = 0x17,\n  Break = 0x1f,\n}\n\nexport type CborMap<T = any> =\n  | {\n      [key: string]: CborValue<T>;\n    }\n  | {\n      [key: string | number]: CborValue<T>;\n    }\n  | {\n      [key: string | symbol]: CborValue<T>;\n    }\n  | {\n      [key: string | number | symbol]: CborValue<T>;\n    };\n\nexport enum CborMajorType {\n  UnsignedInteger = 0,\n  NegativeInteger = 1,\n  ByteString = 2,\n  TextString = 3,\n  Array = 4,\n  Map = 5,\n  Tag = 6,\n  Simple = 7,\n}\n\nexport const TOKEN_VALUE_MAX = 0x17;\nexport const ONE_BYTE_MAX = 0xff;\nexport const TWO_BYTES_MAX = 0xffff;\nexport const FOUR_BYTES_MAX = 0xffffffff;\n/**\n * The maximum value that can be encoded in 8 bytes: `18446744073709551615n`.\n */\nexport const EIGHT_BYTES_MAX = BigInt('0xffffffffffffffff');\n\nexport enum CborMinorType {\n  Value = 23,\n  OneByte = 24,\n  TwoBytes = 25,\n  FourBytes = 26,\n  EightBytes = 27,\n  Indefinite = 31,\n}\n","export const IS_LITTLE_ENDIAN = false;\n","export function isNil<T>(\n  value: T | null | undefined,\n): value is null | undefined {\n  return value === null || value === undefined;\n}\n\nexport function isNotNil<T>(value: T | null | undefined): value is T {\n  return !isNil(value);\n}\n","export function resizeUint8Array(\n  array: Uint8Array,\n  newSize: number,\n): Uint8Array {\n  const newArray = new Uint8Array(newSize);\n  newArray.set(array);\n  return newArray;\n}\n","import {\n  CBOR_SELF_DESCRIBED_TAG,\n  CBOR_STOP_CODE,\n  CborMajorType,\n  CborMap,\n  CborMinorType,\n  CborNumber,\n  CborSimple,\n  CborSimpleType,\n  CborValue,\n} from '../cbor-value';\nimport { IS_LITTLE_ENDIAN, isNil } from '../util';\nimport { DecodingError } from './decoding-error';\n\nconst textDecoder = new TextDecoder();\n\nfunction decodeMajorType(firstByte: number): CborMajorType {\n  return (firstByte & 0b1110_0000) >> 5;\n}\n\nfunction decodeInfo(firstByte: number): number {\n  return firstByte & 0b0001_1111;\n}\n\nlet cborBytes = new Uint8Array();\nlet dataView: DataView | undefined;\nlet bytesOffset = 0;\n\n/**\n * A function that can be used to manipulate the decoded value.\n * See {@link decode} for more information.\n * @param value - The value to manipulate.\n * @param key - The current key in a map, or the current stringified index in an array.\n * @returns The manipulated value.\n */\nexport type Reviver<K extends CborValue = CborValue> = (\n  value: K,\n  key?: K extends CborValue ? string : keyof K,\n) => [K] extends [never] ? CborValue : K;\n\n/**\n * Decodes a CBOR byte array into a value.\n * See {@link Reviver} for more information.\n * @param input - The CBOR byte array to decode.\n * @param reviver - A function that can be used to manipulate the decoded value.\n * @returns The decoded value.\n *\n * @example Simple\n * ```ts\n * const value = true;\n * const encoded = encode(value); // returns `Uint8Array [245]` (which is \"F5\" in hex)\n * const decoded = decode(encoded); // returns `true`\n * ```\n *\n * @example Reviver\n * ```ts\n * const bytes = ...; // Uint8Array corresponding to the CBOR encoding of `{ a: 1, b: 2 }`\n * const reviver: Reviver = val => (typeof val === 'number' ? val * 2 : val);\n * decode(bytes, reviver); // returns `{ a: 2, b: 4 }`\n * ```\n */\nexport function decode<T extends CborValue = CborValue>(\n  input: Uint8Array,\n  reviver?: Reviver<T>,\n): T {\n  cborBytes = input;\n  bytesOffset = 0;\n\n  const decodedItem = decodeItem(reviver as Reviver | undefined) as T;\n  return (reviver?.(decodedItem as T) ?? decodedItem) as T;\n}\n\nfunction decodeItem(reviver?: Reviver): CborValue {\n  const [majorType, info] = decodeNextByte();\n\n  switch (majorType) {\n    case CborMajorType.UnsignedInteger:\n      return decodeUnsignedInteger(info);\n\n    case CborMajorType.NegativeInteger:\n      return decodeNegativeInteger(info);\n\n    case CborMajorType.ByteString:\n      return decodeByteString(info);\n\n    case CborMajorType.TextString:\n      return decodeTextString(info);\n\n    case CborMajorType.Array:\n      return decodeArray(info, reviver);\n\n    case CborMajorType.Map:\n      return decodeMap(info, reviver);\n\n    case CborMajorType.Tag:\n      return decodeTag(info, reviver);\n\n    case CborMajorType.Simple:\n      return decodeSimple(info);\n  }\n\n  throw new DecodingError(`Unsupported major type: ${majorType}`);\n}\n\nfunction decodeNextByte(): [CborMajorType, number] {\n  const firstByte = cborBytes.at(bytesOffset);\n  if (isNil(firstByte)) {\n    throw new DecodingError('Provided CBOR data is empty');\n  }\n\n  const majorType = decodeMajorType(firstByte);\n  const info = decodeInfo(firstByte);\n\n  bytesOffset++;\n  return [majorType, info];\n}\n\nfunction decodeArray(info: number, reviver?: Reviver): CborValue[] {\n  const arrayLength = decodeUnsignedInteger(info);\n\n  if (arrayLength === Infinity) {\n    const values: CborValue[] = [];\n    let decodedItem = decodeItem(reviver);\n\n    while (decodedItem !== CBOR_STOP_CODE) {\n      values.push(reviver?.(decodedItem) ?? decodedItem);\n      decodedItem = decodeItem(reviver);\n    }\n\n    return values;\n  }\n\n  const values = new Array<CborValue>(arrayLength);\n  for (let i = 0; i < arrayLength; i++) {\n    const decodedItem = decodeItem(reviver);\n    values[i] = reviver?.(decodedItem) ?? decodedItem;\n  }\n  return values;\n}\n\nfunction decodeSimple(info: number): CborSimple {\n  switch (info) {\n    case CborSimpleType.False: {\n      return false;\n    }\n    case CborSimpleType.True: {\n      return true;\n    }\n    case CborSimpleType.Null: {\n      return null;\n    }\n    case CborSimpleType.Undefined: {\n      return undefined;\n    }\n    case CborSimpleType.Break: {\n      return CBOR_STOP_CODE;\n    }\n  }\n\n  throw new DecodingError(`Unrecognized simple type: ${info.toString(2)}`);\n}\n\nfunction decodeMap(info: number, reviver?: Reviver): CborMap {\n  const mapLength = decodeUnsignedInteger(info);\n  const map: CborMap = {};\n\n  if (mapLength === Infinity) {\n    let [majorType, info] = decodeNextByte();\n\n    while (\n      majorType !== CborMajorType.Simple &&\n      info !== CborSimpleType.Break\n    ) {\n      const key = decodeTextString(info);\n      const decodedItem = decodeItem(reviver);\n      map[key] = reviver?.(decodedItem, key) ?? decodedItem;\n\n      [majorType, info] = decodeNextByte();\n    }\n\n    return map;\n  }\n\n  for (let i = 0; i < mapLength; i++) {\n    const [majorType, info] = decodeNextByte();\n\n    if (majorType !== CborMajorType.TextString) {\n      throw new DecodingError('Map keys must be text strings');\n    }\n\n    const key = decodeTextString(info);\n    const decodedItem = decodeItem(reviver);\n    map[key] = reviver?.(decodedItem, key) ?? decodedItem;\n  }\n\n  return map;\n}\n\nfunction decodeUnsignedInteger(info: number): CborNumber {\n  if (info <= CborMinorType.Value) {\n    return info;\n  }\n\n  dataView = new DataView(cborBytes.buffer, cborBytes.byteOffset + bytesOffset);\n  switch (info) {\n    case CborMinorType.OneByte:\n      bytesOffset++;\n      return dataView.getUint8(0);\n\n    case CborMinorType.TwoBytes:\n      bytesOffset += 2;\n      return dataView.getUint16(0, IS_LITTLE_ENDIAN);\n\n    case CborMinorType.FourBytes:\n      bytesOffset += 4;\n      return dataView.getUint32(0, IS_LITTLE_ENDIAN);\n\n    case CborMinorType.EightBytes:\n      bytesOffset += 8;\n      return dataView.getBigUint64(0, IS_LITTLE_ENDIAN);\n\n    case CborMinorType.Indefinite:\n      return Infinity;\n\n    default:\n      throw new DecodingError(`Unsupported integer info: ${info.toString(2)}`);\n  }\n}\n\nfunction decodeNegativeInteger(info: number): CborNumber {\n  const value = decodeUnsignedInteger(info);\n  const negativeValue = typeof value === 'number' ? -1 - value : -1n - value;\n\n  return negativeValue;\n}\n\nfunction decodeByteString(info: number): Uint8Array {\n  const byteLength = decodeUnsignedInteger(info);\n  if (byteLength > Number.MAX_SAFE_INTEGER) {\n    throw new DecodingError('Byte length is too large');\n  }\n\n  const safeByteLength = Number(byteLength);\n  bytesOffset += safeByteLength;\n  return cborBytes.slice(bytesOffset - safeByteLength, bytesOffset);\n}\n\nfunction decodeTextString(info: number): string {\n  const bytes = decodeByteString(info);\n\n  return textDecoder.decode(bytes);\n}\n\nfunction decodeTag(info: number, reviver?: Reviver): CborValue {\n  const value = decodeUnsignedInteger(info);\n\n  if (value === CBOR_SELF_DESCRIBED_TAG) {\n    return decodeItem(reviver);\n  }\n\n  throw new DecodingError(`Unsupported tag: ${value}.`);\n}\n","export class EncodingError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'SerializationError';\n  }\n}\n","import {\n  CborMajorType,\n  CborMap,\n  CborMinorType,\n  CborNumber,\n  CborSimple,\n  CborSimpleType,\n  CborValue,\n  ReplacedCborValue,\n  EIGHT_BYTES_MAX,\n  FOUR_BYTES_MAX,\n  ONE_BYTE_MAX,\n  TOKEN_VALUE_MAX,\n  TWO_BYTES_MAX,\n  CBOR_SELF_DESCRIBED_TAG,\n} from '../cbor-value';\nimport { EncodingError } from './encoding-error';\nimport { IS_LITTLE_ENDIAN, resizeUint8Array } from '../util';\n\nconst INITIAL_BUFFER_SIZE = 2 * 1_024;\nconst SAFE_BUFFER_END_OFFSET = 100;\n\nconst textEncoder = new TextEncoder();\n\nfunction encodeMajorType(majorType: CborMajorType): number {\n  return majorType << 5;\n}\n\nlet target = new Uint8Array(INITIAL_BUFFER_SIZE);\nlet targetView = new DataView(target.buffer);\nlet bytesOffset = 0;\nlet mapEntries: [string, CborValue][] = [];\n\n/**\n * A function that can be used to manipulate the input before it is encoded.\n * See {@link encode} for more information.\n * @param value - The value to manipulate.\n * @param key - The current key in a map, or the current stringified index in an array.\n * @returns The manipulated value.\n */\nexport type Replacer<T = any> = (\n  value: CborValue<T>,\n  key?: string,\n) => ReplacedCborValue<T>;\n\n/**\n * Encodes a value into a CBOR byte array.\n * @param value - The value to encode.\n * @param replacer - A function that can be used to manipulate the input before it is encoded.\n * @returns The encoded value.\n *\n * @example Simple\n * ```ts\n * const value = true;\n * const encoded = encode(value); // returns `Uint8Array [245]` (which is \"F5\" in hex)\n * ```\n *\n * @example Replacer\n * ```ts\n * const replacer: Replacer = val => (typeof val === 'number' ? val * 2 : val);\n * encode({ a: 1, b: 2 }, replacer); // returns the Uint8Array corresponding to the CBOR encoding of `{ a: 2, b: 4 }`\n * ```\n */\nexport function encode<T = any>(\n  value: CborValue<T>,\n  replacer?: Replacer<T>,\n): Uint8Array {\n  bytesOffset = 0;\n\n  const transformedValue = replacer?.(value) ?? value;\n  encodeItem(transformedValue, replacer);\n\n  return target.slice(0, bytesOffset);\n}\n\n/**\n * Encodes a value into a CBOR byte array (same as {@link encode}), but prepends the self-described CBOR tag (55799).\n * @param value - The value to encode.\n * @param replacer - A function that can be used to manipulate the input before it is encoded.\n * @returns The encoded value with the self-described CBOR tag.\n *\n * @example\n * ```ts\n * const value = true;\n * const encoded = encodeWithSelfDescribedTag(value); // returns the Uint8Array [217, 217, 247, 245] (which is \"D9D9F7F5\" in hex)\n * ```\n */\nexport function encodeWithSelfDescribedTag<T = any>(\n  value: CborValue<T>,\n  replacer?: Replacer<T>,\n): Uint8Array {\n  bytesOffset = 0;\n\n  const transformedValue = replacer?.(value) ?? value;\n  encodeTag(CBOR_SELF_DESCRIBED_TAG, transformedValue, replacer);\n\n  return target.slice(0, bytesOffset);\n}\n\nfunction encodeItem(item: CborValue, replacer?: Replacer): void {\n  if (bytesOffset > target.length - SAFE_BUFFER_END_OFFSET) {\n    target = resizeUint8Array(target, target.length * 2);\n    targetView = new DataView(target.buffer);\n  }\n\n  if (item === false || item === true || item === null || item === undefined) {\n    encodeSimple(item);\n    return;\n  }\n\n  if (typeof item === 'number' || typeof item === 'bigint') {\n    encodeNumber(item);\n    return;\n  }\n\n  if (typeof item === 'string') {\n    encodeTextString(item);\n    return;\n  }\n\n  if (item instanceof Uint8Array) {\n    encodeByteString(item);\n    return;\n  }\n\n  if (item instanceof ArrayBuffer) {\n    encodeByteString(new Uint8Array(item));\n    return;\n  }\n\n  if (Array.isArray(item)) {\n    encodeArray(item, replacer);\n    return;\n  }\n\n  if (typeof item === 'object') {\n    encodeMap(item, replacer);\n    return;\n  }\n\n  throw new EncodingError(`Unsupported type: ${typeof item}`);\n}\n\nfunction encodeArray(items: CborValue[], replacer?: Replacer): void {\n  encodeHeader(CborMajorType.Array, items.length);\n\n  items.forEach((item, i) => {\n    encodeItem(replacer?.(item, i.toString()) ?? item, replacer);\n  });\n}\n\nfunction encodeMap(map: CborMap, replacer?: Replacer): void {\n  mapEntries = Object.entries(map);\n\n  encodeHeader(CborMajorType.Map, mapEntries.length);\n\n  mapEntries.forEach(([key, value]) => {\n    encodeTextString(key);\n    encodeItem(replacer?.(value, key) ?? value, replacer);\n  });\n}\n\nfunction encodeHeader(majorType: CborMajorType, value: CborNumber): void {\n  if (value <= TOKEN_VALUE_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | Number(value),\n    );\n    return;\n  }\n\n  if (value <= ONE_BYTE_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | CborMinorType.OneByte,\n    );\n    targetView.setUint8(bytesOffset, Number(value));\n    bytesOffset += 1;\n    return;\n  }\n\n  if (value <= TWO_BYTES_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | CborMinorType.TwoBytes,\n    );\n    targetView.setUint16(bytesOffset, Number(value), IS_LITTLE_ENDIAN);\n    bytesOffset += 2;\n    return;\n  }\n\n  if (value <= FOUR_BYTES_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | CborMinorType.FourBytes,\n    );\n    targetView.setUint32(bytesOffset, Number(value), IS_LITTLE_ENDIAN);\n    bytesOffset += 4;\n    return;\n  }\n\n  if (value <= EIGHT_BYTES_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | CborMinorType.EightBytes,\n    );\n    targetView.setBigUint64(bytesOffset, BigInt(value), IS_LITTLE_ENDIAN);\n    bytesOffset += 8;\n    return;\n  }\n\n  throw new EncodingError(`Value too large to encode: ${value}`);\n}\n\nfunction encodeSimple(value: CborSimple): void {\n  encodeHeader(CborMajorType.Simple, mapSimple(value));\n}\n\nfunction mapSimple(value: CborSimple): CborSimpleType {\n  if (value === false) {\n    return CborSimpleType.False;\n  }\n\n  if (value === true) {\n    return CborSimpleType.True;\n  }\n\n  if (value === null) {\n    return CborSimpleType.Null;\n  }\n\n  if (value === undefined) {\n    return CborSimpleType.Undefined;\n  }\n\n  throw new EncodingError(`Unrecognized simple value: ${value.toString()}`);\n}\n\nfunction encodeBytes(majorType: CborMajorType, value: Uint8Array): void {\n  encodeHeader(majorType, value.length);\n\n  if (bytesOffset > target.length - value.length) {\n    target = resizeUint8Array(target, target.length + value.length);\n    targetView = new DataView(target.buffer);\n  }\n  target.set(value, bytesOffset);\n  bytesOffset += value.length;\n}\n\nfunction encodeInteger(majorType: CborMajorType, value: CborNumber): void {\n  encodeHeader(majorType, value);\n}\n\nfunction encodeUnsignedInteger(value: CborNumber): void {\n  encodeInteger(CborMajorType.UnsignedInteger, value);\n}\n\nfunction encodeNegativeInteger(value: CborNumber): void {\n  encodeInteger(\n    CborMajorType.NegativeInteger,\n    typeof value === 'bigint' ? -1n - value : -1 - value,\n  );\n}\n\nfunction encodeNumber(value: CborNumber): void {\n  value >= 0 ? encodeUnsignedInteger(value) : encodeNegativeInteger(value);\n}\n\nfunction encodeTextString(value: string): void {\n  encodeBytes(CborMajorType.TextString, textEncoder.encode(value));\n}\n\nfunction encodeByteString(value: Uint8Array): void {\n  encodeBytes(CborMajorType.ByteString, value);\n}\n\nfunction encodeTag(tag: number, value: CborValue, replacer?: Replacer): void {\n  encodeHeader(CborMajorType.Tag, tag);\n  encodeItem(value, replacer);\n}\n"],"names":["DecodingError","message","CBOR_SELF_DESCRIBED_TAG","CBOR_STOP_CODE","CborSimpleType","CborMajorType","TOKEN_VALUE_MAX","ONE_BYTE_MAX","TWO_BYTES_MAX","FOUR_BYTES_MAX","EIGHT_BYTES_MAX","CborMinorType","IS_LITTLE_ENDIAN","isNil","value","resizeUint8Array","array","newSize","newArray","textDecoder","decodeMajorType","firstByte","decodeInfo","cborBytes","dataView","bytesOffset","decode","input","reviver","decodedItem","decodeItem","majorType","info","decodeNextByte","decodeUnsignedInteger","decodeNegativeInteger","decodeByteString","decodeTextString","decodeArray","decodeMap","decodeTag","decodeSimple","arrayLength","values","i","mapLength","map","key","byteLength","safeByteLength","bytes","EncodingError","INITIAL_BUFFER_SIZE","SAFE_BUFFER_END_OFFSET","textEncoder","encodeMajorType","target","targetView","mapEntries","encode","replacer","transformedValue","encodeItem","encodeWithSelfDescribedTag","encodeTag","item","encodeSimple","encodeNumber","encodeTextString","encodeByteString","encodeArray","encodeMap","items","encodeHeader","mapSimple","encodeBytes","encodeInteger","encodeUnsignedInteger","encodeNegativeInteger","tag"],"mappings":"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"}