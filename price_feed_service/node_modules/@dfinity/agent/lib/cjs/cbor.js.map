{"version":3,"file":"cbor.js","sourceRoot":"","sources":["../../src/cbor.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,wBAoBC;AAMD,wBAMC;AAxDD,kDAA+C;AAC/C,oDAAsC;AACtC,2CAAmF;AACnF,+CAA0C;AAE1C;;GAEG;AACH,MAAsB,WAAW;CAKhC;AALD,kCAKC;AAED,SAAS,kBAAkB,CAAC,KAAc;IACxC,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,IAAI,aAAa,IAAI,KAAK,CAAC;AAC/E,CAAC;AAED;;;;GAIG;AACH,SAAgB,MAAM,CAAC,KAAc;IACnC,IAAI,CAAC;QACH,OAAO,IAAI,CAAC,0BAA0B,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE;YACpD,IAAI,qBAAS,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,CAAC;gBACjC,OAAO,KAAK,CAAC,YAAY,EAAE,CAAC;YAC9B,CAAC;YAED,IAAI,iBAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC;gBAC3B,OAAO,KAAK,CAAC,QAAQ,EAAE,CAAC;YAC1B,CAAC;YAED,IAAI,kBAAkB,CAAC,KAAK,CAAC,EAAE,CAAC;gBAC9B,OAAO,KAAK,CAAC,WAAW,EAAE,CAAC;YAC7B,CAAC;YAED,OAAO,KAAK,CAAC;QACf,CAAC,CAAC,CAAC;IACL,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,MAAM,sBAAU,CAAC,QAAQ,CAAC,IAAI,+BAAmB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;IACnE,CAAC;AACH,CAAC;AAED;;;GAGG;AACH,SAAgB,MAAM,CAAI,KAAiB;IACzC,IAAI,CAAC;QACH,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAM,CAAC;IACjC,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,MAAM,sBAAU,CAAC,QAAQ,CAAC,IAAI,+BAAmB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;IACnE,CAAC;AACH,CAAC;AAED,6EAA6E;AAChE,QAAA,IAAI,GAAG;IAClB,MAAM;IACN,MAAM;CACP,CAAC","sourcesContent":["import { Principal } from '@dfinity/principal';\nimport * as cbor from '@dfinity/cbor';\nimport { CborDecodeErrorCode, CborEncodeErrorCode, InputError } from './errors.ts';\nimport { Expiry } from './agent/index.ts';\n\n/**\n * Used to extend classes that need to provide a custom value for the CBOR encoding process.\n */\nexport abstract class ToCborValue {\n  /**\n   * Returns a value that can be encoded with CBOR. Typically called in the replacer function of the {@link encode} function.\n   */\n  public abstract toCborValue(): cbor.CborValue;\n}\n\nfunction hasCborValueMethod(value: unknown): value is ToCborValue {\n  return typeof value === 'object' && value !== null && 'toCborValue' in value;\n}\n\n/**\n * Encode a JavaScript value into CBOR. If the value is an instance of {@link ToCborValue},\n * the {@link ToCborValue.toCborValue} method will be called to get the value to encode.\n * @param value The value to encode\n */\nexport function encode(value: unknown): Uint8Array {\n  try {\n    return cbor.encodeWithSelfDescribedTag(value, value => {\n      if (Principal.isPrincipal(value)) {\n        return value.toUint8Array();\n      }\n\n      if (Expiry.isExpiry(value)) {\n        return value.toBigInt();\n      }\n\n      if (hasCborValueMethod(value)) {\n        return value.toCborValue();\n      }\n\n      return value;\n    });\n  } catch (error) {\n    throw InputError.fromCode(new CborEncodeErrorCode(error, value));\n  }\n}\n\n/**\n * Decode a CBOR encoded value into a JavaScript value.\n * @param input The CBOR encoded value\n */\nexport function decode<T>(input: Uint8Array): T {\n  try {\n    return cbor.decode(input) as T;\n  } catch (error) {\n    throw InputError.fromCode(new CborDecodeErrorCode(error, input));\n  }\n}\n\n// Not strictly necessary, we're just keeping it for backwards compatibility.\nexport const Cbor = {\n  encode,\n  decode,\n};\n"]}