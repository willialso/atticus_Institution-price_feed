{"version":3,"file":"auth.js","sourceRoot":"","sources":["../../src/auth.ts"],"names":[],"mappings":";;;AA0IA,4DAQC;AAlJD,kDAA+C;AAE/C,mDAA8C;AAC9C,+CAA8D;AAC9D,iDAA6D;AAiD7D;;GAEG;AACH,MAAsB,YAAY;IAahC;;;OAGG;IACI,YAAY;QACjB,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;YACrB,IAAI,CAAC,UAAU,GAAG,qBAAS,CAAC,kBAAkB,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QAC9F,CAAC;QACD,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAED;;;;;OAKG;IACI,KAAK,CAAC,gBAAgB,CAAC,OAAyB;QACrD,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,EAAE,GAAG,OAAO,CAAC;QACpC,MAAM,SAAS,GAAG,IAAA,2BAAW,EAAC,IAAI,CAAC,CAAC;QACpC,OAAO;YACL,GAAG,MAAM;YACT,IAAI,EAAE;gBACJ,OAAO,EAAE,IAAI;gBACb,aAAa,EAAE,IAAI,CAAC,YAAY,EAAE,CAAC,KAAK,EAAE;gBAC1C,UAAU,EAAE,MAAM,IAAI,CAAC,IAAI,CAAC,IAAA,mBAAW,EAAC,0CAA2B,EAAE,SAAS,CAAC,CAAC;aACjF;SACF,CAAC;IACJ,CAAC;CACF;AA1CD,oCA0CC;AAED,MAAa,iBAAiB;IACrB,YAAY;QACjB,OAAO,qBAAS,CAAC,SAAS,EAAE,CAAC;IAC/B,CAAC;IAEM,KAAK,CAAC,gBAAgB,CAAC,OAAyB;QACrD,OAAO;YACL,GAAG,OAAO;YACV,IAAI,EAAE,EAAE,OAAO,EAAE,OAAO,CAAC,IAAI,EAAE;SAChC,CAAC;IACJ,CAAC;CACF;AAXD,8CAWC;AAuBD;;;GAGG;AACH,SAAgB,wBAAwB,CACtC,QAA0C;IAE1C,MAAM,iBAAiB,GACrB,cAAc,IAAI,QAAQ;QACxB,CAAC,CAAC,EAAE,IAAI,EAAE,mBAAmB,EAAE,SAAS,EAAE,IAAA,kBAAU,EAAC,QAAQ,CAAC,YAAY,EAAE,CAAC,KAAK,EAAE,CAAC,EAAE;QACvF,CAAC,CAAC,EAAE,IAAI,EAAE,mBAAmB,EAAE,CAAC;IACpC,OAAO,iBAAiB,CAAC;AAC3B,CAAC","sourcesContent":["import { Principal } from '@dfinity/principal';\nimport { type HttpAgentRequest } from './agent/http/types.ts';\nimport { requestIdOf } from './request_id.ts';\nimport { bytesToHex, concatBytes } from '@noble/hashes/utils';\nimport { IC_REQUEST_DOMAIN_SEPARATOR } from './constants.ts';\n/**\n * A Key Pair, containing a secret and public key.\n */\nexport interface KeyPair {\n  secretKey: Uint8Array;\n  publicKey: PublicKey;\n}\n\n/**\n * A public key that is DER encoded. This is a branded Uint8Array.\n */\nexport type DerEncodedPublicKey = Uint8Array & { __derEncodedPublicKey__?: void };\n\n/**\n * A signature array buffer.\n */\nexport type Signature = Uint8Array & { __signature__: void };\n\n/**\n * A Public Key implementation.\n */\nexport interface PublicKey {\n  toDer(): DerEncodedPublicKey;\n  // rawKey, toRaw, and derKey are optional for backwards compatibility.\n  toRaw?(): Uint8Array;\n  rawKey?: Uint8Array;\n  derKey?: DerEncodedPublicKey;\n}\n\n/**\n * A General Identity object. This does not have to be a private key (for example,\n * the Anonymous identity), but it must be able to transform request.\n */\nexport interface Identity {\n  /**\n   * Get the principal represented by this identity. Normally should be a\n   * `Principal.selfAuthenticating()`.\n   */\n  getPrincipal(): Principal;\n\n  /**\n   * Transform a request into a signed version of the request. This is done last\n   * after the transforms on the body of a request. The returned object can be\n   * anything, but must be serializable to CBOR.\n   */\n  transformRequest(request: HttpAgentRequest): Promise<unknown>;\n}\n\n/**\n * An Identity that can sign blobs.\n */\nexport abstract class SignIdentity implements Identity {\n  protected _principal: Principal | undefined;\n\n  /**\n   * Returns the public key that would match this identity's signature.\n   */\n  public abstract getPublicKey(): PublicKey;\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   */\n  public abstract sign(blob: Uint8Array): Promise<Signature>;\n\n  /**\n   * Get the principal represented by this identity. Normally should be a\n   * `Principal.selfAuthenticating()`.\n   */\n  public getPrincipal(): Principal {\n    if (!this._principal) {\n      this._principal = Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n    }\n    return this._principal;\n  }\n\n  /**\n   * Transform a request into a signed version of the request. This is done last\n   * after the transforms on the body of a request. The returned object can be\n   * anything, but must be serializable to CBOR.\n   * @param request - internet computer request to transform\n   */\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    const { body, ...fields } = request;\n    const requestId = requestIdOf(body);\n    return {\n      ...fields,\n      body: {\n        content: body,\n        sender_pubkey: this.getPublicKey().toDer(),\n        sender_sig: await this.sign(concatBytes(IC_REQUEST_DOMAIN_SEPARATOR, requestId)),\n      },\n    };\n  }\n}\n\nexport class AnonymousIdentity implements Identity {\n  public getPrincipal(): Principal {\n    return Principal.anonymous();\n  }\n\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    return {\n      ...request,\n      body: { content: request.body },\n    };\n  }\n}\n\n/*\n * We need to communicate with other agents on the page about identities,\n * but those messages may need to go across boundaries where it's not possible to\n * serialize/deserialize object prototypes easily.\n * So these are lightweight, serializable objects that contain enough information to recreate\n * SignIdentities, but don't commit to having all methods of SignIdentity.\n *\n * Use Case:\n * * DOM Events that let differently-versioned components communicate to one another about\n *   Identities, even if they're using slightly different versions of agent packages to\n *   create/interpret them.\n */\nexport interface AnonymousIdentityDescriptor {\n  type: 'AnonymousIdentity';\n}\nexport interface PublicKeyIdentityDescriptor {\n  type: 'PublicKeyIdentity';\n  publicKey: string;\n}\nexport type IdentityDescriptor = AnonymousIdentityDescriptor | PublicKeyIdentityDescriptor;\n\n/**\n * Create an IdentityDescriptor from a @dfinity/identity Identity\n * @param identity - identity describe in returned descriptor\n */\nexport function createIdentityDescriptor(\n  identity: SignIdentity | AnonymousIdentity,\n): IdentityDescriptor {\n  const identityIndicator: IdentityDescriptor =\n    'getPublicKey' in identity\n      ? { type: 'PublicKeyIdentity', publicKey: bytesToHex(identity.getPublicKey().toDer()) }\n      : { type: 'AnonymousIdentity' };\n  return identityIndicator;\n}\n"]}