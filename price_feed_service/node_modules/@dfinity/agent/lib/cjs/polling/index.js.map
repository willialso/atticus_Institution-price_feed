{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/polling/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { type RequestId } from '../request_id.ts';\nimport { type CreateCertificateOptions, Certificate, lookupResultToBuffer } from '../certificate.ts';\nimport { type Agent, type ReadStateResponse } from '../agent/api.ts';\nimport { Principal } from '@dfinity/principal';\nimport {\n  CertifiedRejectErrorCode,\n  ExternalError,\n  InputError,\n  InvalidReadStateRequestErrorCode,\n  MissingRootKeyErrorCode,\n  RejectError,\n  RequestStatusDoneNoReplyErrorCode,\n  UnknownError,\n  UNREACHABLE_ERROR,\n} from '../errors.ts';\n\nexport * as strategy from './strategy.ts';\nimport { defaultStrategy } from './strategy.ts';\nimport { ReadRequestType, type ReadStateRequest } from '../agent/http/types.ts';\nimport { RequestStatusResponseStatus } from '../agent/index.ts';\nimport { utf8ToBytes } from '@noble/hashes/utils';\nexport { defaultStrategy } from './strategy.ts';\n\nexport type PollStrategy = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<void>;\n\nexport type PollStrategyFactory = () => PollStrategy;\n\ninterface SignedReadStateRequestWithExpiry extends ReadStateRequest {\n  body: {\n    content: Pick<ReadStateRequest, 'request_type' | 'ingress_expiry'>;\n  };\n}\n\n/**\n * Options for controlling polling behavior\n */\nexport interface PollingOptions {\n  /**\n   * A polling strategy that dictates how much and often we should poll the\n   * read_state endpoint to get the result of an update call.\n   * @default defaultStrategy()\n   */\n  strategy?: PollStrategy;\n\n  /**\n   * Whether to reuse the same signed request for polling or create a new unsigned request each time.\n   * @default false\n   */\n  preSignReadStateRequest?: boolean;\n\n  /**\n   * Optional replacement function that verifies the BLS signature of a certificate.\n   */\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n\n  /**\n   * The request to use for polling. If not provided, a new request will be created.\n   * This is only used if `preSignReadStateRequest` is set to false.\n   */\n  request?: ReadStateRequest;\n}\n\nexport const DEFAULT_POLLING_OPTIONS: PollingOptions = {\n  strategy: defaultStrategy(),\n  preSignReadStateRequest: false,\n};\n\n/**\n * Check if an object has a property\n * @param value the object that might have the property\n * @param property the key of property we're looking for\n */\nfunction hasProperty<O extends object, P extends string>(\n  value: O,\n  property: P,\n): value is O & Record<P, unknown> {\n  return Object.prototype.hasOwnProperty.call(value, property);\n}\n\nfunction isObjectWithProperty<O extends object, P extends string>(\n  value: unknown,\n  property: P,\n): value is O & Record<P, unknown> {\n  return value !== null && typeof value === 'object' && hasProperty(value, property);\n}\n\nfunction hasFunction<O extends object, P extends string>(\n  value: O,\n  property: P,\n): value is O & Record<P, (...args: unknown[]) => unknown> {\n  return hasProperty(value, property) && typeof value[property] === 'function';\n}\n\n/**\n * Check if value is a signed read state request with expiry\n * @param value to check\n */\nfunction isSignedReadStateRequestWithExpiry(\n  value: unknown,\n): value is SignedReadStateRequestWithExpiry {\n  return (\n    isObjectWithProperty(value, 'body') &&\n    isObjectWithProperty(value.body, 'content') &&\n    (value.body.content as { request_type: ReadRequestType }).request_type ===\n      ReadRequestType.ReadState &&\n    isObjectWithProperty(value.body.content, 'ingress_expiry') &&\n    typeof value.body.content.ingress_expiry === 'object' &&\n    value.body.content.ingress_expiry !== null &&\n    hasFunction(value.body.content.ingress_expiry, 'toHash')\n  );\n}\n\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param options polling options to control behavior\n */\nexport async function pollForResponse(\n  agent: Agent,\n  canisterId: Principal,\n  requestId: RequestId,\n  options: PollingOptions = {},\n): Promise<{\n  certificate: Certificate;\n  reply: Uint8Array;\n}> {\n  const path = [utf8ToBytes('request_status'), requestId];\n\n  let state: ReadStateResponse;\n  let currentRequest: ReadStateRequest | undefined;\n  const preSignReadStateRequest = options.preSignReadStateRequest ?? false;\n  if (preSignReadStateRequest) {\n    // If preSignReadStateRequest is true, we need to create a new request\n    currentRequest = await constructRequest({\n      paths: [path],\n      agent,\n      pollingOptions: options,\n    });\n    state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n  } else {\n    // If preSignReadStateRequest is false, we use the default strategy and sign the request each time\n    state = await agent.readState(canisterId, { paths: [path] });\n  }\n\n  if (agent.rootKey == null) {\n    throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n  }\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify: options.blsVerify,\n  });\n\n  const maybeBuf = lookupResultToBuffer(cert.lookup_path([...path, utf8ToBytes('status')]));\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n\n  switch (status) {\n    case RequestStatusResponseStatus.Replied: {\n      return {\n        reply: lookupResultToBuffer(cert.lookup_path([...path, 'reply']))!,\n        certificate: cert,\n      };\n    }\n\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing: {\n      // Execute the polling strategy, then retry.\n      const strategy = options.strategy ?? defaultStrategy();\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, {\n        ...options,\n        request: currentRequest,\n      });\n    }\n\n    case RequestStatusResponseStatus.Rejected: {\n      const rejectCode = new Uint8Array(\n        lookupResultToBuffer(cert.lookup_path([...path, 'reject_code']))!,\n      )[0];\n      const rejectMessage = new TextDecoder().decode(\n        lookupResultToBuffer(cert.lookup_path([...path, 'reject_message']))!,\n      );\n      const errorCodeBuf = lookupResultToBuffer(cert.lookup_path([...path, 'error_code']));\n      const errorCode = errorCodeBuf ? new TextDecoder().decode(errorCodeBuf) : undefined;\n      throw RejectError.fromCode(\n        new CertifiedRejectErrorCode(requestId, rejectCode, rejectMessage, errorCode),\n      );\n    }\n\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw UnknownError.fromCode(new RequestStatusDoneNoReplyErrorCode(requestId));\n  }\n  throw UNREACHABLE_ERROR;\n}\n\n// Determine if we should reuse the read state request or create a new one\n// based on the options provided.\n\n/**\n * Constructs a read state request for the given paths.\n * If the request is already signed and has an expiry, it will be returned as is.\n * Otherwise, a new request will be created.\n * @param options The options to use for creating the request.\n * @param options.paths The paths to read from.\n * @param options.agent The agent to use to create the request.\n * @param options.pollingOptions The options to use for creating the request.\n * @returns The read state request.\n */\nexport async function constructRequest(options: {\n  paths: Uint8Array[][];\n  agent: Agent;\n  pollingOptions: PollingOptions;\n}): Promise<ReadStateRequest> {\n  const { paths, agent, pollingOptions } = options;\n  if (pollingOptions.request && isSignedReadStateRequestWithExpiry(pollingOptions.request)) {\n    return pollingOptions.request;\n  }\n  const request = await agent.createReadStateRequest?.(\n    {\n      paths,\n    },\n    undefined,\n  );\n  if (!isSignedReadStateRequestWithExpiry(request)) {\n    throw InputError.fromCode(new InvalidReadStateRequestErrorCode(request));\n  }\n  return request;\n}\n"]}