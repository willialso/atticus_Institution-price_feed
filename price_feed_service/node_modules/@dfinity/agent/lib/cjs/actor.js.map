{"version":3,"file":"actor.js","sourceRoot":"","sources":["../../src/actor.ts"],"names":[],"mappings":";;;AAAA,+CAM0B;AAC1B,2CAUqB;AACrB,4CAAsC;AACtC,iDAAmG;AACnG,kDAA+C;AAC/C,qDAAoG;AACpG,oDAAkD;AAClD,+CAAkD;AA2JlD,MAAM,cAAc,GAAG,MAAM,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC;AAOvD;;;GAGG;AACH,MAAa,KAAK;IAChB;;;;OAIG;IACI,MAAM,CAAC,OAAO,CAAC,KAAY;QAChC,OAAO,KAAK,CAAC,cAAc,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC;IAC5C,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,WAAW,CAAC,KAAY;QACpC,OAAO,KAAK,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC;IACvC,CAAC;IAEM,MAAM,CAAC,YAAY,CAAC,KAAY;QACrC,OAAO,qBAAS,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;IACjE,CAAC;IAEM,MAAM,CAAC,gBAAgB,CAC5B,gBAAsC,EACtC,OAA8B;QAE9B,MAAM,OAAO,GAAG,gBAAgB,CAAC,EAAE,GAAG,EAAH,YAAG,EAAE,CAAC,CAAC;QAE1C,MAAM,aAAc,SAAQ,KAAK;YAG/B,YAAY,MAAmB;gBAC7B,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC;oBACvB,MAAM,sBAAU,CAAC,QAAQ,CAAC,IAAI,sCAA0B,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;gBAC/E,CAAC;gBACD,MAAM,UAAU,GACd,OAAO,MAAM,CAAC,UAAU,KAAK,QAAQ;oBACnC,CAAC,CAAC,qBAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC;oBACvC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC;gBAExB,KAAK,CAAC;oBACJ,MAAM,EAAE;wBACN,GAAG,oBAAoB;wBACvB,GAAG,MAAM;wBACT,UAAU;qBACX;oBACD,OAAO;iBACR,CAAC,CAAC;gBAEH,KAAK,MAAM,CAAC,UAAU,EAAE,IAAI,CAAC,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC;oBACjD,IAAI,OAAO,EAAE,WAAW,EAAE,CAAC;wBACzB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,sCAA8B,CAAC,CAAC;oBACxD,CAAC;oBACD,IAAI,OAAO,EAAE,WAAW,EAAE,CAAC;wBACzB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,qCAA6B,CAAC,CAAC;oBACvD,CAAC;oBAED,IAAI,CAAC,UAAU,CAAC,GAAG,kBAAkB,CAAC,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC;gBAClF,CAAC;YACH,CAAC;SACF;QAED,OAAO,aAAa,CAAC;IACvB,CAAC;IAEM,MAAM,CAAC,WAAW,CACvB,gBAAsC,EACtC,aAA0B;QAE1B,IAAI,CAAC,aAAa,CAAC,UAAU,EAAE,CAAC;YAC9B,MAAM,sBAAU,CAAC,QAAQ,CAAC,IAAI,sCAA0B,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC;QACtF,CAAC;QACD,OAAO,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,CAAC,CAClD,aAAa,CACiB,CAAC;IACnC,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,0BAA0B,CACtC,gBAAsC,EACtC,aAA0B;QAE1B,OAAO,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,gBAAgB,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC,CAAC,CACzE,aAAa,CACmD,CAAC;IACrE,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,8BAA8B,CAC1C,gBAAsC,EACtC,aAA0B,EAC1B,oBAA0C;QACxC,WAAW,EAAE,IAAI;QACjB,WAAW,EAAE,IAAI;KAClB;QAED,OAAO,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,gBAAgB,EAAE,iBAAiB,CAAC,CAAC,CACrE,aAAa,CAC4C,CAAC;IAC9D,CAAC;IAID,YAAsB,QAAuB;QAC3C,IAAI,CAAC,cAAc,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IACjD,CAAC;CACF;AApHD,sBAoHC;AAED,oEAAoE;AACpE,sEAAsE;AACtE,6BAA6B;AAC7B,SAAS,iBAAiB,CAAC,KAAiB,EAAE,GAAe;IAC3D,MAAM,YAAY,GAAG,YAAG,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IAC5C,QAAQ,YAAY,CAAC,MAAM,EAAE,CAAC;QAC5B,KAAK,CAAC;YACJ,OAAO,SAAS,CAAC;QACnB,KAAK,CAAC;YACJ,OAAO,YAAY,CAAC,CAAC,CAAC,CAAC;QACzB;YACE,OAAO,YAAY,CAAC;IACxB,CAAC;AACH,CAAC;AAED,MAAM,oBAAoB,GAAyB;IACjD,cAAc,EAAE,kCAAuB;CACxC,CAAC;AAIW,QAAA,8BAA8B,GAAG,cAAc,CAAC;AAChD,QAAA,6BAA6B,GAAG,aAAa,CAAC;AAE3D,SAAS,kBAAkB,CACzB,KAAY,EACZ,UAAkB,EAClB,IAAmB,EACnB,SAAiD;IAEjD,IAAI,MAAqE,CAAC;IAC1E,IAAI,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,iBAAiB,CAAC,EAAE,CAAC;QACvF,MAAM,GAAG,KAAK,EAAE,OAAO,EAAE,GAAG,IAAI,EAAE,EAAE;YAClC,sDAAsD;YACtD,OAAO,GAAG;gBACR,GAAG,OAAO;gBACV,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC,UAAU,EAAE,IAAI,EAAE;oBACjE,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC,MAAM;oBAC/B,GAAG,OAAO;iBACX,CAAC;aACH,CAAC;YAEF,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,cAAc,CAAC,CAAC,MAAM,CAAC,KAAK,IAAI,IAAI,oBAAS,EAAE,CAAC;YACrF,MAAM,GAAG,GAAG,qBAAS,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,IAAI,KAAK,CAAC,cAAc,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;YAC1F,MAAM,GAAG,GAAG,YAAG,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;YAE5C,MAAM,MAAM,GAAG,MAAM,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE;gBACpC,UAAU;gBACV,GAAG;gBACH,mBAAmB,EAAE,OAAO,CAAC,mBAAmB;aACjD,CAAC,CAAC;YACH,MAAM,WAAW,GAAG;gBAClB,GAAG,MAAM,CAAC,WAAW;gBACrB,cAAc,EAAE,MAAM,CAAC,cAAc;aACf,CAAC;YAEzB,QAAQ,MAAM,CAAC,MAAM,EAAE,CAAC;gBACtB,KAAK,8BAAmB,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAClC,MAAM,0BAA0B,GAAG,IAAI,sCAA0B,CAC/D,MAAM,CAAC,SAAS,EAChB,MAAM,CAAC,WAAW,EAClB,MAAM,CAAC,cAAc,EACrB,MAAM,CAAC,UAAU,EACjB,MAAM,CAAC,UAAU,CAClB,CAAC;oBACF,0BAA0B,CAAC,WAAW,GAAG;wBACvC,UAAU,EAAE,GAAG;wBACf,UAAU;wBACV,WAAW;qBACZ,CAAC;oBACF,MAAM,uBAAW,CAAC,QAAQ,CAAC,0BAA0B,CAAC,CAAC;gBACzD,CAAC;gBAED,KAAK,8BAAmB,CAAC,OAAO;oBAC9B,OAAO,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,sCAA8B,CAAC;wBAC9D,CAAC,CAAC;4BACE,WAAW;4BACX,MAAM,EAAE,iBAAiB,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC;yBAC3D;wBACH,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAC3D,CAAC;QACH,CAAC,CAAC;IACJ,CAAC;SAAM,CAAC;QACN,MAAM,GAAG,KAAK,EAAE,OAAO,EAAE,GAAG,IAAI,EAAE,EAAE;YAClC,sDAAsD;YACtD,OAAO,GAAG;gBACR,GAAG,OAAO;gBACV,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC,MAAM,CAAC,aAAa,EAAE,CAAC,UAAU,EAAE,IAAI,EAAE;oBAChE,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC,MAAM;oBAC/B,GAAG,OAAO;iBACX,CAAC;aACH,CAAC;YAEF,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,cAAc,CAAC,CAAC,MAAM,CAAC,KAAK,IAAI,oBAAS,CAAC,UAAU,EAAE,CAAC;YAE5F,MAAM,EAAE,UAAU,EAAE,mBAAmB,EAAE,cAAc,EAAE,GAAG;gBAC1D,GAAG,oBAAoB;gBACvB,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC,MAAM;gBAC/B,GAAG,OAAO;aACX,CAAC;YACF,MAAM,GAAG,GAAG,qBAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACvC,MAAM,IAAI,GAAG,mBAAmB,KAAK,SAAS,CAAC,CAAC,CAAC,qBAAS,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;YAC3F,MAAM,GAAG,GAAG,YAAG,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;YAE5C,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,cAAc,EAAE,GAAG,MAAM,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE;gBACpE,UAAU;gBACV,GAAG;gBACH,mBAAmB,EAAE,IAAI;gBACzB,KAAK,EAAE,OAAO,CAAC,KAAK;aACrB,CAAC,CAAC;YACH,IAAI,KAA6B,CAAC;YAClC,IAAI,WAAoC,CAAC;YACzC,IAAI,IAAA,2BAAgB,EAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;gBACpC,IAAI,KAAK,CAAC,OAAO,IAAI,IAAI,EAAE,CAAC;oBAC1B,MAAM,yBAAa,CAAC,QAAQ,CAAC,IAAI,mCAAuB,EAAE,CAAC,CAAC;gBAC9D,CAAC;gBACD,MAAM,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC;gBACvC,WAAW,GAAG,MAAM,4BAAW,CAAC,MAAM,CAAC;oBACrC,WAAW,EAAE,IAAI;oBACjB,OAAO,EAAE,KAAK,CAAC,OAAO;oBACtB,UAAU,EAAE,qBAAS,CAAC,IAAI,CAAC,UAAU,CAAC;oBACtC,SAAS;iBACV,CAAC,CAAC;gBACH,MAAM,IAAI,GAAG,CAAC,IAAA,mBAAW,EAAC,gBAAgB,CAAC,EAAE,SAAS,CAAC,CAAC;gBACxD,MAAM,MAAM,GAAG,IAAI,WAAW,EAAE,CAAC,MAAM,CACrC,IAAA,qCAAoB,EAAC,WAAW,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC,CACnE,CAAC;gBAEF,QAAQ,MAAM,EAAE,CAAC;oBACf,KAAK,SAAS;wBACZ,KAAK,GAAG,IAAA,qCAAoB,EAAC,WAAW,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;wBAC1E,MAAM;oBACR,KAAK,UAAU,CAAC,CAAC,CAAC;wBAChB,4CAA4C;wBAC5C,MAAM,UAAU,GAAG,IAAI,UAAU,CAC/B,IAAA,qCAAoB,EAAC,WAAW,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,EAAE,aAAa,CAAC,CAAC,CAAE,CACzE,CAAC,CAAC,CAAC,CAAC;wBACL,MAAM,aAAa,GAAG,IAAI,WAAW,EAAE,CAAC,MAAM,CAC5C,IAAA,qCAAoB,EAAC,WAAW,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAE,CAC5E,CAAC;wBAEF,MAAM,cAAc,GAAG,IAAA,qCAAoB,EACzC,WAAW,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,EAAE,YAAY,CAAC,CAAC,CACjD,CAAC;wBACF,MAAM,UAAU,GAAG,cAAc;4BAC/B,CAAC,CAAC,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,cAAc,CAAC;4BAC1C,CAAC,CAAC,SAAS,CAAC;wBAEd,MAAM,wBAAwB,GAAG,IAAI,oCAAwB,CAC3D,SAAS,EACT,UAAU,EACV,aAAa,EACb,UAAU,CACX,CAAC;wBACF,wBAAwB,CAAC,WAAW,GAAG;4BACrC,UAAU,EAAE,GAAG;4BACf,UAAU;4BACV,WAAW,EAAE,QAAQ;yBACtB,CAAC;wBACF,MAAM,uBAAW,CAAC,QAAQ,CAAC,wBAAwB,CAAC,CAAC;oBACvD,CAAC;gBACH,CAAC;YACH,CAAC;iBAAM,IAAI,IAAA,2BAAgB,EAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;gBAC3C,0EAA0E;gBAC1E,MAAM,EAAE,WAAW,EAAE,cAAc,EAAE,UAAU,EAAE,GAAG,QAAQ,CAAC,IAAI,CAAC;gBAClE,MAAM,wBAAwB,GAAG,IAAI,oCAAwB,CAC3D,SAAS,EACT,WAAW,EACX,cAAc,EACd,UAAU,CACX,CAAC;gBACF,wBAAwB,CAAC,WAAW,GAAG;oBACrC,UAAU,EAAE,GAAG;oBACf,UAAU;oBACV,WAAW,EAAE,QAAQ;iBACtB,CAAC;gBACF,MAAM,uBAAW,CAAC,QAAQ,CAAC,wBAAwB,CAAC,CAAC;YACvD,CAAC;YAED,+DAA+D;YAC/D,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE,CAAC;gBAC5B,MAAM,WAAW,GAAmB;oBAClC,GAAG,cAAc;oBACjB,SAAS;iBACV,CAAC;gBACF,gEAAgE;gBAChE,MAAM,QAAQ,GAAG,MAAM,IAAA,0BAAe,EAAC,KAAK,EAAE,IAAI,EAAE,SAAS,EAAE,WAAW,CAAC,CAAC;gBAC5E,WAAW,GAAG,QAAQ,CAAC,WAAW,CAAC;gBACnC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC;YACzB,CAAC;YACD,MAAM,wBAAwB,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,sCAA8B,CAAC,CAAC;YAC3F,MAAM,wBAAwB,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,qCAA6B,CAAC,CAAC;YAE1F,MAAM,WAAW,GAAG,EAAE,GAAG,QAAQ,EAAE,cAAc,EAAyB,CAAC;YAC3E,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;gBACxB,IAAI,wBAAwB,IAAI,wBAAwB,EAAE,CAAC;oBACzD,OAAO;wBACL,WAAW;wBACX,WAAW;wBACX,MAAM,EAAE,iBAAiB,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC;qBAChD,CAAC;gBACJ,CAAC;qBAAM,IAAI,wBAAwB,EAAE,CAAC;oBACpC,OAAO;wBACL,WAAW;wBACX,MAAM,EAAE,iBAAiB,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC;qBAChD,CAAC;gBACJ,CAAC;qBAAM,IAAI,wBAAwB,EAAE,CAAC;oBACpC,OAAO;wBACL,WAAW;wBACX,MAAM,EAAE,iBAAiB,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC;qBAChD,CAAC;gBACJ,CAAC;gBACD,OAAO,iBAAiB,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;YACjD,CAAC;iBAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBACtC,OAAO,wBAAwB;oBAC7B,CAAC,CAAC;wBACE,WAAW,EAAE,QAAQ;wBACrB,MAAM,EAAE,SAAS;qBAClB;oBACH,CAAC,CAAC,SAAS,CAAC;YAChB,CAAC;iBAAM,CAAC;gBACN,MAAM,wBAAY,CAAC,QAAQ,CACzB,IAAI,+BAAmB,CACrB,0CAA0C,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAC5F,CACF,CAAC;YACJ,CAAC;QACH,CAAC,CAAC;IACJ,CAAC;IAED,MAAM,OAAO,GAAG,CAAC,GAAG,IAAe,EAAE,EAAE,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,CAAC;IAC5D,OAAO,CAAC,WAAW;QACjB,CAAC,OAAmB,EAAE,EAAE,CACxB,CAAC,GAAG,IAAe,EAAE,EAAE,CACrB,MAAM,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,CAAC;IAC7B,OAAO,OAAsB,CAAC;AAChC,CAAC","sourcesContent":["import {\n  type Agent,\n  type HttpDetailsResponse,\n  isV2ResponseBody,\n  isV3ResponseBody,\n  QueryResponseStatus,\n} from './agent/index.ts';\nimport {\n  CertifiedRejectErrorCode,\n  ExternalError,\n  InputError,\n  MissingCanisterIdErrorCode,\n  MissingRootKeyErrorCode,\n  RejectError,\n  UncertifiedRejectErrorCode,\n  UnexpectedErrorCode,\n  UnknownError,\n} from './errors.ts';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, type PollingOptions, DEFAULT_POLLING_OPTIONS } from './polling/index.ts';\nimport { Principal } from '@dfinity/principal';\nimport { Certificate, type CreateCertificateOptions, lookupResultToBuffer } from './certificate.ts';\nimport { HttpAgent } from './agent/http/index.ts';\nimport { utf8ToBytes } from '@noble/hashes/utils';\n\n/**\n * Configuration to make calls to the Replica.\n */\nexport interface CallConfig {\n  /**\n   * An agent to use in this call, otherwise the actor or call will try to discover the\n   * agent to use.\n   */\n  agent?: Agent;\n\n  /**\n   * Options for controlling polling behavior.\n   */\n  pollingOptions?: PollingOptions;\n\n  /**\n   * The canister ID of this Actor.\n   */\n  canisterId?: string | Principal;\n\n  /**\n   * The effective canister ID. This should almost always be ignored.\n   */\n  effectiveCanisterId?: Principal;\n\n  /**\n   * The nonce to use for this call. This is used to prevent replay attacks.\n   */\n  nonce?: Uint8Array;\n}\n\n/**\n * Configuration that can be passed to customize the Actor behaviour.\n */\nexport interface ActorConfig extends CallConfig {\n  /**\n   * The Canister ID of this Actor. This is required for an Actor.\n   */\n  canisterId: string | Principal;\n\n  /**\n   * An override function for update calls' CallConfig. This will be called on every calls.\n   */\n  callTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * An override function for query calls' CallConfig. This will be called on every query.\n   */\n  queryTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * Polyfill for BLS Certificate verification in case wasm is not supported\n   */\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n\n  /**\n   * Polling options to use when making update calls. This will override the default DEFAULT_POLLING_OPTIONS.\n   */\n  pollingOptions?: PollingOptions;\n}\n\n// TODO: move this to proper typing when Candid support TypeScript.\n/**\n * A subclass of an actor. Actor class itself is meant to be a based class.\n */\nexport type ActorSubclass<T = Record<string, ActorMethod>> = Actor & T;\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethod<Args extends unknown[] = unknown[], Ret = unknown> {\n  (...args: Args): Promise<Ret>;\n\n  withOptions(options: CallConfig): (...args: Args) => Promise<Ret>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodWithHttpDetails<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{ httpDetails: HttpDetailsResponse; result: Ret }>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodExtended<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{\n    certificate?: Certificate;\n    httpDetails?: HttpDetailsResponse;\n    result: Ret;\n  }>;\n}\n\nexport type FunctionWithArgsAndReturn<Args extends unknown[] = unknown[], Ret = unknown> = (\n  ...args: Args\n) => Ret;\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedWithHttpDetails<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodWithHttpDetails<Args, Ret>\n    : never;\n};\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedExtended<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodExtended<Args, Ret>\n    : never;\n};\n\n/**\n * The mode used when installing a canister.\n */\nexport type CanisterInstallMode =\n  | {\n      reinstall: null;\n    }\n  | {\n      upgrade:\n        | []\n        | [\n            {\n              skip_pre_upgrade: [] | [boolean];\n            },\n          ];\n    }\n  | {\n      install: null;\n    };\n\n/**\n * Internal metadata for actors. It's an enhanced version of ActorConfig with\n * some fields marked as required (as they are defaulted) and canisterId as\n * a Principal type.\n */\ninterface ActorMetadata {\n  service: IDL.ServiceClass;\n  agent?: Agent;\n  config: ActorConfig;\n}\n\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n\nexport interface CreateActorClassOpts {\n  httpDetails?: boolean;\n  certificate?: boolean;\n}\n\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  public static agentOf(actor: Actor): Agent | undefined {\n    return actor[metadataSymbol].config.agent;\n  }\n\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  public static interfaceOf(actor: Actor): IDL.ServiceClass {\n    return actor[metadataSymbol].service;\n  }\n\n  public static canisterIdOf(actor: Actor): Principal {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n\n  public static createActorClass(\n    interfaceFactory: IDL.InterfaceFactory,\n    options?: CreateActorClassOpts,\n  ): ActorConstructor {\n    const service = interfaceFactory({ IDL });\n\n    class CanisterActor extends Actor {\n      [x: string]: ActorMethod;\n\n      constructor(config: ActorConfig) {\n        if (!config.canisterId) {\n          throw InputError.fromCode(new MissingCanisterIdErrorCode(config.canisterId));\n        }\n        const canisterId =\n          typeof config.canisterId === 'string'\n            ? Principal.fromText(config.canisterId)\n            : config.canisterId;\n\n        super({\n          config: {\n            ...DEFAULT_ACTOR_CONFIG,\n            ...config,\n            canisterId,\n          },\n          service,\n        });\n\n        for (const [methodName, func] of service._fields) {\n          if (options?.httpDetails) {\n            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n          }\n          if (options?.certificate) {\n            func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);\n          }\n\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n\n    return CanisterActor;\n  }\n\n  public static createActor<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<T> {\n    if (!configuration.canisterId) {\n      throw InputError.fromCode(new MissingCanisterIdErrorCode(configuration.canisterId));\n    }\n    return new (this.createActorClass(interfaceFactory))(\n      configuration,\n    ) as unknown as ActorSubclass<T>;\n  }\n\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @deprecated - use createActor with actorClassOptions instead\n   */\n  public static createActorWithHttpDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<ActorMethodMappedWithHttpDetails<T>> {\n    return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedWithHttpDetails<T>>;\n  }\n\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @param actorClassOptions - options for the actor class extended details to return with the result\n   */\n  public static createActorWithExtendedDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n    actorClassOptions: CreateActorClassOpts = {\n      httpDetails: true,\n      certificate: true,\n    },\n  ): ActorSubclass<ActorMethodMappedExtended<T>> {\n    return new (this.createActorClass(interfaceFactory, actorClassOptions))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedExtended<T>>;\n  }\n\n  private [metadataSymbol]: ActorMetadata;\n\n  protected constructor(metadata: ActorMetadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n}\n\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types: IDL.Type[], msg: Uint8Array) {\n  const returnValues = IDL.decode(types, msg);\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\n\nconst DEFAULT_ACTOR_CONFIG: Partial<ActorConfig> = {\n  pollingOptions: DEFAULT_POLLING_OPTIONS,\n};\n\nexport type ActorConstructor = new (config: ActorConfig) => ActorSubclass;\n\nexport const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nexport const ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';\n\nfunction _createActorMethod(\n  actor: Actor,\n  methodName: string,\n  func: IDL.FuncClass,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): ActorMethod {\n  let caller: (options: CallConfig, ...args: unknown[]) => Promise<unknown>;\n  if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.queryTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || new HttpAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n\n      const result = await agent.query(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: options.effectiveCanisterId,\n      });\n      const httpDetails = {\n        ...result.httpDetails,\n        requestDetails: result.requestDetails,\n      } as HttpDetailsResponse;\n\n      switch (result.status) {\n        case QueryResponseStatus.Rejected: {\n          const uncertifiedRejectErrorCode = new UncertifiedRejectErrorCode(\n            result.requestId,\n            result.reject_code,\n            result.reject_message,\n            result.error_code,\n            result.signatures,\n          );\n          uncertifiedRejectErrorCode.callContext = {\n            canisterId: cid,\n            methodName,\n            httpDetails,\n          };\n          throw RejectError.fromCode(uncertifiedRejectErrorCode);\n        }\n\n        case QueryResponseStatus.Replied:\n          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)\n            ? {\n                httpDetails,\n                result: decodeReturnValue(func.retTypes, result.reply.arg),\n              }\n            : decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.callTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || HttpAgent.createSync();\n\n      const { canisterId, effectiveCanisterId, pollingOptions } = {\n        ...DEFAULT_ACTOR_CONFIG,\n        ...actor[metadataSymbol].config,\n        ...options,\n      };\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n\n      const { requestId, response, requestDetails } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid,\n        nonce: options.nonce,\n      });\n      let reply: Uint8Array | undefined;\n      let certificate: Certificate | undefined;\n      if (isV3ResponseBody(response.body)) {\n        if (agent.rootKey == null) {\n          throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n        }\n        const cert = response.body.certificate;\n        certificate = await Certificate.create({\n          certificate: cert,\n          rootKey: agent.rootKey,\n          canisterId: Principal.from(canisterId),\n          blsVerify,\n        });\n        const path = [utf8ToBytes('request_status'), requestId];\n        const status = new TextDecoder().decode(\n          lookupResultToBuffer(certificate.lookup_path([...path, 'status'])),\n        );\n\n        switch (status) {\n          case 'replied':\n            reply = lookupResultToBuffer(certificate.lookup_path([...path, 'reply']));\n            break;\n          case 'rejected': {\n            // Find rejection details in the certificate\n            const rejectCode = new Uint8Array(\n              lookupResultToBuffer(certificate.lookup_path([...path, 'reject_code']))!,\n            )[0];\n            const rejectMessage = new TextDecoder().decode(\n              lookupResultToBuffer(certificate.lookup_path([...path, 'reject_message']))!,\n            );\n\n            const error_code_buf = lookupResultToBuffer(\n              certificate.lookup_path([...path, 'error_code']),\n            );\n            const error_code = error_code_buf\n              ? new TextDecoder().decode(error_code_buf)\n              : undefined;\n\n            const certifiedRejectErrorCode = new CertifiedRejectErrorCode(\n              requestId,\n              rejectCode,\n              rejectMessage,\n              error_code,\n            );\n            certifiedRejectErrorCode.callContext = {\n              canisterId: cid,\n              methodName,\n              httpDetails: response,\n            };\n            throw RejectError.fromCode(certifiedRejectErrorCode);\n          }\n        }\n      } else if (isV2ResponseBody(response.body)) {\n        // handle v2 response errors by throwing an UpdateCallRejectedError object\n        const { reject_code, reject_message, error_code } = response.body;\n        const certifiedRejectErrorCode = new CertifiedRejectErrorCode(\n          requestId,\n          reject_code,\n          reject_message,\n          error_code,\n        );\n        certifiedRejectErrorCode.callContext = {\n          canisterId: cid,\n          methodName,\n          httpDetails: response,\n        };\n        throw RejectError.fromCode(certifiedRejectErrorCode);\n      }\n\n      // Fall back to polling if we receive an Accepted response code\n      if (response.status === 202) {\n        const pollOptions: PollingOptions = {\n          ...pollingOptions,\n          blsVerify,\n        };\n        // Contains the certificate and the reply from the boundary node\n        const response = await pollForResponse(agent, ecid, requestId, pollOptions);\n        certificate = response.certificate;\n        reply = response.reply;\n      }\n      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n      const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);\n\n      const httpDetails = { ...response, requestDetails } as HttpDetailsResponse;\n      if (reply !== undefined) {\n        if (shouldIncludeHttpDetails && shouldIncludeCertificate) {\n          return {\n            httpDetails,\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        } else if (shouldIncludeCertificate) {\n          return {\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        } else if (shouldIncludeHttpDetails) {\n          return {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        }\n        return decodeReturnValue(func.retTypes, reply);\n      } else if (func.retTypes.length === 0) {\n        return shouldIncludeHttpDetails\n          ? {\n              httpDetails: response,\n              result: undefined,\n            }\n          : undefined;\n      } else {\n        throw UnknownError.fromCode(\n          new UnexpectedErrorCode(\n            `Call was returned undefined, but type [${func.retTypes.map(t => t.display()).join(',')}].`,\n          ),\n        );\n      }\n    };\n  }\n\n  const handler = (...args: unknown[]) => caller({}, ...args);\n  handler.withOptions =\n    (options: CallConfig) =>\n    (...args: unknown[]) =>\n      caller(options, ...args);\n  return handler as ActorMethod;\n}\n"]}