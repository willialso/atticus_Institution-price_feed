{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/canisterStatus/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,oBAAoB,CAAC;AAC/C,OAAO,EACL,gCAAgC,EAChC,uBAAuB,EACvB,iCAAiC,EACjC,eAAe,EACf,6BAA6B,EAC7B,aAAa,EACb,aAAa,EACb,UAAU,EACV,UAAU,EACV,YAAY,EACZ,uBAAuB,EACvB,mBAAmB,EACnB,UAAU,GACX,MAAM,cAAc,CAAC;AAEtB,OAAO,EAEL,WAAW,EAEX,aAAa,EACb,qBAAqB,EACrB,gBAAgB,EAChB,WAAW,EACX,oBAAoB,EACpB,cAAc,EAEd,mBAAmB,GACpB,MAAM,mBAAmB,CAAC;AAC3B,OAAO,KAAK,IAAI,MAAM,YAAY,CAAC;AACnC,OAAO,EAAE,YAAY,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAE3D,OAAO,EAAE,WAAW,EAAE,UAAU,EAAE,MAAM,qBAAqB,CAAC;AAoC9D;;;;;GAKG;AACH,MAAM,OAAO,UAAU;IAIrB,YACE,GAAW,EACX,IAA2B,EAC3B,cAA2D;QAE3D,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;IACvC,CAAC;CACF;AAoCD;;;;;;;;;;;;;;;GAeG;AACH,MAAM,CAAC,MAAM,OAAO,GAAG,KAAK,EAAE,OAI7B,EAAsB,EAAE;IACvB,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,OAAO,CAAC;IACjC,MAAM,UAAU,GAAG,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IAEtD,MAAM,WAAW,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;IACxC,MAAM,MAAM,GAAG,IAAI,GAAG,EAAyB,CAAC;IAEhD,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;QAC/C,MAAM,WAAW,GAAG,UAAU,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;QAEjD,OAAO,CAAC,KAAK,IAAI,EAAE;YACjB,IAAI,CAAC;gBACH,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,SAAS,CAAC,UAAU,EAAE;oBACjD,KAAK,EAAE,CAAC,WAAW,CAAC;iBACrB,CAAC,CAAC;gBACH,IAAI,KAAK,CAAC,OAAO,IAAI,IAAI,EAAE,CAAC;oBAC1B,MAAM,aAAa,CAAC,QAAQ,CAAC,IAAI,uBAAuB,EAAE,CAAC,CAAC;gBAC9D,CAAC;gBAED,MAAM,IAAI,GAAG,MAAM,WAAW,CAAC,MAAM,CAAC;oBACpC,WAAW,EAAE,QAAQ,CAAC,WAAW;oBACjC,OAAO,EAAE,KAAK,CAAC,OAAO;oBACtB,UAAU,EAAE,UAAU;oBACtB,uBAAuB,EAAE,IAAI;iBAC9B,CAAC,CAAC;gBAEH,MAAM,MAAM,GAAG,CAAC,IAAiB,EAAE,IAAU,EAAE,EAAE;oBAC/C,IAAI,IAAI,KAAK,QAAQ,EAAE,CAAC;wBACtB,IAAI,KAAK,CAAC,OAAO,IAAI,IAAI,EAAE,CAAC;4BAC1B,MAAM,aAAa,CAAC,QAAQ,CAAC,IAAI,uBAAuB,EAAE,CAAC,CAAC;wBAC9D,CAAC;wBACD,MAAM,IAAI,GAAG,aAAa,CAAC,QAAQ,CAAC,WAAW,EAAE,UAAU,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC;wBAC5E,OAAO;4BACL,IAAI;4BACJ,IAAI;yBACL,CAAC;oBACJ,CAAC;yBAAM,CAAC;wBACN,OAAO;4BACL,IAAI;4BACJ,IAAI,EAAE,oBAAoB,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;yBAC1D,CAAC;oBACJ,CAAC;gBACH,CAAC,CAAC;gBAEF,oDAAoD;gBACpD,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;gBACxD,IAAI,CAAC,IAAI,EAAE,CAAC;oBACV,wCAAwC;oBACxC,OAAO,CAAC,IAAI,CAAC,oCAAoC,IAAI,8BAA8B,CAAC,CAAC;oBACrF,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE,CAAC;wBAC7B,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;oBACzB,CAAC;yBAAM,CAAC;wBACN,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;oBAC7B,CAAC;gBACH,CAAC;qBAAM,CAAC;oBACN,QAAQ,IAAI,EAAE,CAAC;wBACb,KAAK,MAAM,CAAC,CAAC,CAAC;4BACZ,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;4BACnC,MAAM;wBACR,CAAC;wBACD,KAAK,aAAa,CAAC,CAAC,CAAC;4BACnB,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;4BAC1C,MAAM;wBACR,CAAC;wBACD,KAAK,aAAa,CAAC,CAAC,CAAC;4BACnB,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;4BACnC,MAAM;wBACR,CAAC;wBACD,KAAK,QAAQ,CAAC,CAAC,CAAC;4BACd,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;4BACvB,MAAM;wBACR,CAAC;wBACD,KAAK,QAAQ,CAAC,CAAC,CAAC;4BACd,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;4BACjD,MAAM;wBACR,CAAC;wBACD,OAAO,CAAC,CAAC,CAAC;4BACR,iCAAiC;4BACjC,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,KAAK,IAAI,IAAI,IAAI,MAAM,IAAI,IAAI,EAAE,CAAC;gCAChE,QAAQ,IAAI,CAAC,cAAc,EAAE,CAAC;oCAC5B,KAAK,KAAK;wCACR,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;wCAC3B,MAAM;oCACR,KAAK,QAAQ,CAAC,CAAC,CAAC;wCACd,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;wCACzC,MAAM;oCACR,CAAC;oCACD,KAAK,MAAM,CAAC,CAAC,CAAC;wCACZ,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;wCACxC,MAAM;oCACR,CAAC;oCACD,KAAK,KAAK,CAAC,CAAC,CAAC;wCACX,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;wCACvC,MAAM;oCACR,CAAC;oCACD,KAAK,OAAO,CAAC,CAAC,CAAC;wCACb,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;oCACvD,CAAC;gCACH,CAAC;4BACH,CAAC;wBACH,CAAC;oBACH,CAAC;gBACH,CAAC;YACH,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,yCAAyC;gBACzC,IAAI,KAAK,YAAY,UAAU,IAAI,KAAK,CAAC,OAAO,CAAC,gCAAgC,CAAC,EAAE,CAAC;oBACnF,MAAM,KAAK,CAAC;gBACd,CAAC;gBACD,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,KAAK,IAAI,IAAI,IAAI,MAAM,IAAI,IAAI,EAAE,CAAC;oBAChE,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;gBAC7B,CAAC;qBAAM,CAAC;oBACN,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBACzB,CAAC;gBACD,OAAO,CAAC,KAAK,EAAE,CAAC;gBAChB,OAAO,CAAC,IAAI,CAAC,oCAAoC,IAAI,8BAA8B,CAAC,CAAC;gBACrF,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACpB,OAAO,CAAC,QAAQ,EAAE,CAAC;YACrB,CAAC;QACH,CAAC,CAAC,EAAE,CAAC;IACP,CAAC,CAAC,CAAC;IAEH,uDAAuD;IACvD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IAE5B,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,aAAa,GAAG,CAC3B,WAAuB,EACvB,UAAqB,EACrB,QAAqB,EACP,EAAE;IAChB,IAAI,CAAC,UAAU,CAAC,YAAY,EAAE,CAAC;QAC7B,MAAM,UAAU,CAAC,QAAQ,CAAC,IAAI,mBAAmB,CAAC,oBAAoB,CAAC,CAAC,CAAC;IAC3E,CAAC;IACD,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAO,WAAW,CAAC,CAAC;IAC5C,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;IACvB,IAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;IACjC,IAAI,QAAmB,CAAC;IACxB,IAAI,UAAU,IAAI,UAAU,CAAC,SAAS,EAAE,CAAC;QACvC,QAAQ,GAAG,SAAS,CAAC,cAAc,CAAC,IAAI,UAAU,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC;IAC5E,CAAC;IAED,oEAAoE;SAC/D,IAAI,CAAC,UAAU,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE,CAAC;QACxD,QAAQ,GAAG,SAAS,CAAC,kBAAkB,CAAC,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;QAClE,UAAU,GAAG;YACX,SAAS,EAAE,QAAQ,CAAC,YAAY,EAAE;YAClC,WAAW,EAAE,IAAI,UAAU,CAAC,CAAC,CAAC;SAC/B,CAAC;IACJ,CAAC;IACD,sCAAsC;SACjC,CAAC;QACJ,QAAQ,GAAG,SAAS,CAAC,kBAAkB,CACrC,SAAS,CAAC,QAAQ,CAChB,iEAAiE,CAClE,CAAC,YAAY,EAAE,CACjB,CAAC;QACF,UAAU,GAAG;YACX,SAAS,EAAE,QAAQ,CAAC,YAAY,EAAE;YAClC,WAAW,EAAE,IAAI,UAAU,CAAC,CAAC,CAAC;SAC/B,CAAC;IACJ,CAAC;IAED,MAAM,eAAe,GAAG,qBAAqB,CAAC,EAAE,UAAU,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC;IAC9E,IAAI,CAAC,eAAe,EAAE,CAAC;QACrB,MAAM,UAAU,CAAC,QAAQ,CACvB,IAAI,iCAAiC,CAAC,UAAU,EAAE,UAAU,CAAC,SAAS,CAAC,CACxE,CAAC;IACJ,CAAC;IAED,MAAM,kBAAkB,GAAG,cAAc,CAAC,CAAC,QAAQ,EAAE,UAAU,CAAC,SAAS,EAAE,MAAM,CAAC,EAAE,IAAI,CAAC,CAAC;IAC1F,IAAI,kBAAkB,CAAC,MAAM,KAAK,mBAAmB,CAAC,KAAK,EAAE,CAAC;QAC5D,MAAM,aAAa,CAAC,QAAQ,CAAC,IAAI,eAAe,CAAC,gBAAgB,EAAE,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC;IACjG,CAAC;IACD,IAAI,kBAAkB,CAAC,KAAK,YAAY,UAAU,EAAE,CAAC;QACnD,MAAM,YAAY,CAAC,QAAQ,CAAC,IAAI,uBAAuB,CAAC,mBAAmB,CAAC,CAAC,CAAC;IAChF,CAAC;IAED,2DAA2D;IAC3D,MAAM,SAAS,GAAG,aAAa,CAAC,kBAAkB,CAAC,KAAK,CAA2B,CAAC;IACpF,MAAM,QAAQ,GAAG,IAAI,GAAG,EAA+B,CAAC;IAExD,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QACvB,MAAM,OAAO,GAAG,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC;QACjD,MAAM,qBAAqB,GAAG,WAAW,CAAC,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;QACnE,IAAI,qBAAqB,CAAC,MAAM,KAAK,gBAAgB,CAAC,KAAK,EAAE,CAAC;YAC5D,MAAM,aAAa,CAAC,QAAQ,CAC1B,IAAI,eAAe,CAAC,sBAAsB,EAAE,qBAAqB,CAAC,MAAM,CAAC,CAC1E,CAAC;QACJ,CAAC;QAED,MAAM,mBAAmB,GAAG,qBAAqB,CAAC,KAAK,CAAC;QACxD,IAAI,mBAAmB,CAAC,UAAU,KAAK,EAAE,EAAE,CAAC;YAC1C,MAAM,aAAa,CAAC,QAAQ,CAC1B,IAAI,6BAA6B,CAAC,EAAE,EAAE,mBAAmB,CAAC,UAAU,CAAC,CACtE,CAAC;QACJ,CAAC;aAAM,CAAC;YACN,QAAQ,CAAC,GAAG,CAAC,OAAO,EAAE,mBAA0C,CAAC,CAAC;QACpE,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,OAAO;QACL,QAAQ,EAAE,SAAS,CAAC,cAAc,CAAC,IAAI,UAAU,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,EAAE;QACjF,QAAQ;KACT,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,UAAU,GAAG,CAAC,IAAU,EAAE,UAAqB,EAAgB,EAAE;IAC5E,MAAM,kBAAkB,GAAG,UAAU,CAAC,YAAY,EAAE,CAAC;IACrD,QAAQ,IAAI,EAAE,CAAC;QACb,KAAK,MAAM;YACT,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC;QAC/B,KAAK,aAAa;YAChB,OAAO,CAAC,WAAW,CAAC,UAAU,CAAC,EAAE,kBAAkB,EAAE,WAAW,CAAC,aAAa,CAAC,CAAC,CAAC;QACnF,KAAK,aAAa;YAChB,OAAO,CAAC,WAAW,CAAC,UAAU,CAAC,EAAE,kBAAkB,EAAE,WAAW,CAAC,aAAa,CAAC,CAAC,CAAC;QACnF,KAAK,QAAQ;YACX,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC;QACjC,KAAK,QAAQ;YACX,OAAO;gBACL,WAAW,CAAC,UAAU,CAAC;gBACvB,kBAAkB;gBAClB,WAAW,CAAC,UAAU,CAAC;gBACvB,WAAW,CAAC,gBAAgB,CAAC;aAC9B,CAAC;QACJ,OAAO,CAAC,CAAC,CAAC;YACR,iCAAiC;YACjC,IAAI,KAAK,IAAI,IAAI,IAAI,MAAM,IAAI,IAAI,EAAE,CAAC;gBACpC,kCAAkC;gBAClC,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,QAAQ,IAAI,IAAI,CAAC,MAAM,CAAC,YAAY,UAAU,EAAE,CAAC;oBAC3E,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC;oBAC3B,MAAM,OAAO,GAAG,OAAO,QAAQ,KAAK,QAAQ,CAAC,CAAC,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;oBAEhF,OAAO,CAAC,WAAW,CAAC,UAAU,CAAC,EAAE,kBAAkB,EAAE,WAAW,CAAC,UAAU,CAAC,EAAE,OAAO,CAAC,CAAC;oBAEvF,mDAAmD;gBACrD,CAAC;qBAAM,CAAC;oBACN,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC;gBACtB,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IACD,MAAM,YAAY,CAAC,QAAQ,CACzB,IAAI,mBAAmB,CACrB,oFAAoF,IAAI,2BAA2B,CACpH,CACF,CAAC;AACJ,CAAC,CAAC;AAEF,uCAAuC;AACvC,MAAM,iBAAiB,GAAG,CAAC,GAAe,EAAe,EAAE;IACzD,MAAM,cAAc,GAAG,IAAI,CAAC,MAAM,CAAe,GAAG,CAAC,CAAC;IACtD,OAAO,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;QAC9B,OAAO,SAAS,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;IACvC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC","sourcesContent":["import { Principal } from '@dfinity/principal';\nimport {\n  CertificateVerificationErrorCode,\n  MissingRootKeyErrorCode,\n  CertificateNotAuthorizedErrorCode,\n  LookupErrorCode,\n  DerKeyLengthMismatchErrorCode,\n  ExternalError,\n  ProtocolError,\n  TrustError,\n  AgentError,\n  UnknownError,\n  HashTreeDecodeErrorCode,\n  UnexpectedErrorCode,\n  InputError,\n} from '../errors.ts';\nimport { HttpAgent } from '../agent/http/index.ts';\nimport {\n  type Cert,\n  Certificate,\n  type CreateCertificateOptions,\n  flatten_forks,\n  check_canister_ranges,\n  LookupPathStatus,\n  lookup_path,\n  lookupResultToBuffer,\n  lookup_subtree,\n  type LabeledHashTree,\n  LookupSubtreeStatus,\n} from '../certificate.ts';\nimport * as cbor from '../cbor.ts';\nimport { decodeLeb128, decodeTime } from '../utils/leb.ts';\nimport { type DerEncodedPublicKey } from '../auth.ts';\nimport { utf8ToBytes, bytesToHex } from '@noble/hashes/utils';\n\n/**\n * Represents the useful information about a subnet\n * @param {string} subnetId the principal id of the canister's subnet\n * @param {string[]} nodeKeys the keys of the individual nodes in the subnet\n */\nexport type SubnetStatus = {\n  // Principal as a string\n  subnetId: string;\n  nodeKeys: Map<string, DerEncodedPublicKey>;\n  metrics?: {\n    num_canisters: bigint;\n    canister_state_bytes: bigint;\n    consumed_cycles_total: {\n      current: bigint;\n      deleted: bigint;\n    };\n    update_transactions_total: bigint;\n  };\n};\n\n/**\n * Types of an entry on the canisterStatus map.\n * An entry of null indicates that the request failed, due to lack of permissions or the result being missing.\n */\nexport type Status =\n  | string\n  | Uint8Array\n  | Date\n  | Uint8Array[]\n  | Principal[]\n  | SubnetStatus\n  | bigint\n  | null;\n\n/**\n * Interface to define a custom path. Nested paths will be represented as individual buffers, and can be created from text using TextEncoder.\n * @param {string} key the key to use to access the returned value in the canisterStatus map\n * @param {Uint8Array[]} path the path to the desired value, represented as an array of buffers\n * @param {string} decodeStrategy the strategy to use to decode the returned value\n */\nexport class CustomPath implements CustomPath {\n  public key: string;\n  public path: Uint8Array[] | string;\n  public decodeStrategy: 'cbor' | 'hex' | 'leb128' | 'utf-8' | 'raw';\n  constructor(\n    key: string,\n    path: Uint8Array[] | string,\n    decodeStrategy: 'cbor' | 'hex' | 'leb128' | 'utf-8' | 'raw',\n  ) {\n    this.key = key;\n    this.path = path;\n    this.decodeStrategy = decodeStrategy;\n  }\n}\n\n/**\n * @deprecated Use {@link CustomPath} instead\n * @param {string} key the key to use to access the returned value in the canisterStatus map\n * @param {string} path the path to the desired value, represented as a string\n * @param {string} decodeStrategy the strategy to use to decode the returned value\n */\nexport interface MetaData {\n  kind: 'metadata';\n  key: string;\n  path: string | Uint8Array;\n  decodeStrategy: 'cbor' | 'hex' | 'leb128' | 'utf-8' | 'raw';\n}\n\n/**\n * Pre-configured fields for canister status paths\n */\nexport type Path =\n  | 'time'\n  | 'controllers'\n  | 'subnet'\n  | 'module_hash'\n  | 'candid'\n  | MetaData\n  | CustomPath;\n\nexport type StatusMap = Map<Path | string, Status>;\n\nexport type CanisterStatusOptions = {\n  canisterId: Principal;\n  agent: HttpAgent;\n  paths?: Path[] | Set<Path>;\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n};\n\n/**\n * Request information in the request_status state tree for a given canister.\n * Can be used to request information about the canister's controllers, time, module hash, candid interface, and more.\n * @param {CanisterStatusOptions} options {@link CanisterStatusOptions}\n * @param {CanisterStatusOptions['canisterId']} options.canisterId {@link Principal}\n * @param {CanisterStatusOptions['agent']} options.agent {@link HttpAgent} optional authenticated agent to use to make the canister request. Useful for accessing private metadata under icp:private\n * @param {CanisterStatusOptions['paths']} options.paths {@link Path[]}\n * @returns {Status} object populated with data from the requested paths\n * @example\n * const status = await canisterStatus({\n *   paths: ['controllers', 'candid'],\n *   ...options\n * });\n *\n * const controllers = status.get('controllers');\n */\nexport const request = async (options: {\n  canisterId: Principal;\n  agent: HttpAgent;\n  paths?: Path[] | Set<Path>;\n}): Promise<StatusMap> => {\n  const { agent, paths } = options;\n  const canisterId = Principal.from(options.canisterId);\n\n  const uniquePaths = [...new Set(paths)];\n  const status = new Map<string | Path, Status>();\n\n  const promises = uniquePaths.map((path, index) => {\n    const encodedPath = encodePath(path, canisterId);\n\n    return (async () => {\n      try {\n        const response = await agent.readState(canisterId, {\n          paths: [encodedPath],\n        });\n        if (agent.rootKey == null) {\n          throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n        }\n\n        const cert = await Certificate.create({\n          certificate: response.certificate,\n          rootKey: agent.rootKey,\n          canisterId: canisterId,\n          disableTimeVerification: true,\n        });\n\n        const lookup = (cert: Certificate, path: Path) => {\n          if (path === 'subnet') {\n            if (agent.rootKey == null) {\n              throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n            }\n            const data = fetchNodeKeys(response.certificate, canisterId, agent.rootKey);\n            return {\n              path,\n              data,\n            };\n          } else {\n            return {\n              path,\n              data: lookupResultToBuffer(cert.lookup_path(encodedPath)),\n            };\n          }\n        };\n\n        // must pass in the rootKey if we have no delegation\n        const { path, data } = lookup(cert, uniquePaths[index]);\n        if (!data) {\n          // Typically, the cert lookup will throw\n          console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n          if (typeof path === 'string') {\n            status.set(path, null);\n          } else {\n            status.set(path.key, null);\n          }\n        } else {\n          switch (path) {\n            case 'time': {\n              status.set(path, decodeTime(data));\n              break;\n            }\n            case 'controllers': {\n              status.set(path, decodeControllers(data));\n              break;\n            }\n            case 'module_hash': {\n              status.set(path, bytesToHex(data));\n              break;\n            }\n            case 'subnet': {\n              status.set(path, data);\n              break;\n            }\n            case 'candid': {\n              status.set(path, new TextDecoder().decode(data));\n              break;\n            }\n            default: {\n              // Check for CustomPath signature\n              if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                switch (path.decodeStrategy) {\n                  case 'raw':\n                    status.set(path.key, data);\n                    break;\n                  case 'leb128': {\n                    status.set(path.key, decodeLeb128(data));\n                    break;\n                  }\n                  case 'cbor': {\n                    status.set(path.key, cbor.decode(data));\n                    break;\n                  }\n                  case 'hex': {\n                    status.set(path.key, bytesToHex(data));\n                    break;\n                  }\n                  case 'utf-8': {\n                    status.set(path.key, new TextDecoder().decode(data));\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (error) {\n        // Break on signature verification errors\n        if (error instanceof AgentError && error.hasCode(CertificateVerificationErrorCode)) {\n          throw error;\n        }\n        if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n          status.set(path.key, null);\n        } else {\n          status.set(path, null);\n        }\n        console.group();\n        console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n        console.warn(error);\n        console.groupEnd();\n      }\n    })();\n  });\n\n  // Fetch all values separately, as each option can fail\n  await Promise.all(promises);\n\n  return status;\n};\n\nexport const fetchNodeKeys = (\n  certificate: Uint8Array,\n  canisterId: Principal,\n  root_key?: Uint8Array,\n): SubnetStatus => {\n  if (!canisterId._isPrincipal) {\n    throw InputError.fromCode(new UnexpectedErrorCode('Invalid canisterId'));\n  }\n  const cert = cbor.decode<Cert>(certificate);\n  const tree = cert.tree;\n  let delegation = cert.delegation;\n  let subnetId: Principal;\n  if (delegation && delegation.subnet_id) {\n    subnetId = Principal.fromUint8Array(new Uint8Array(delegation.subnet_id));\n  }\n\n  // On local replica, with System type subnet, there is no delegation\n  else if (!delegation && typeof root_key !== 'undefined') {\n    subnetId = Principal.selfAuthenticating(new Uint8Array(root_key));\n    delegation = {\n      subnet_id: subnetId.toUint8Array(),\n      certificate: new Uint8Array(0),\n    };\n  }\n  // otherwise use default NNS subnet id\n  else {\n    subnetId = Principal.selfAuthenticating(\n      Principal.fromText(\n        'tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe',\n      ).toUint8Array(),\n    );\n    delegation = {\n      subnet_id: subnetId.toUint8Array(),\n      certificate: new Uint8Array(0),\n    };\n  }\n\n  const canisterInRange = check_canister_ranges({ canisterId, subnetId, tree });\n  if (!canisterInRange) {\n    throw TrustError.fromCode(\n      new CertificateNotAuthorizedErrorCode(canisterId, delegation.subnet_id),\n    );\n  }\n\n  const subnetLookupResult = lookup_subtree(['subnet', delegation.subnet_id, 'node'], tree);\n  if (subnetLookupResult.status !== LookupSubtreeStatus.Found) {\n    throw ProtocolError.fromCode(new LookupErrorCode('Node not found', subnetLookupResult.status));\n  }\n  if (subnetLookupResult.value instanceof Uint8Array) {\n    throw UnknownError.fromCode(new HashTreeDecodeErrorCode('Invalid node tree'));\n  }\n\n  // The forks are all labeled trees with the <node_id> label\n  const nodeForks = flatten_forks(subnetLookupResult.value) as Array<LabeledHashTree>;\n  const nodeKeys = new Map<string, DerEncodedPublicKey>();\n\n  nodeForks.forEach(fork => {\n    const node_id = Principal.from(fork[1]).toText();\n    const publicKeyLookupResult = lookup_path(['public_key'], fork[2]);\n    if (publicKeyLookupResult.status !== LookupPathStatus.Found) {\n      throw ProtocolError.fromCode(\n        new LookupErrorCode('Public key not found', publicKeyLookupResult.status),\n      );\n    }\n\n    const derEncodedPublicKey = publicKeyLookupResult.value;\n    if (derEncodedPublicKey.byteLength !== 44) {\n      throw ProtocolError.fromCode(\n        new DerKeyLengthMismatchErrorCode(44, derEncodedPublicKey.byteLength),\n      );\n    } else {\n      nodeKeys.set(node_id, derEncodedPublicKey as DerEncodedPublicKey);\n    }\n  });\n\n  return {\n    subnetId: Principal.fromUint8Array(new Uint8Array(delegation.subnet_id)).toText(),\n    nodeKeys,\n  };\n};\n\nexport const encodePath = (path: Path, canisterId: Principal): Uint8Array[] => {\n  const canisterUint8Array = canisterId.toUint8Array();\n  switch (path) {\n    case 'time':\n      return [utf8ToBytes('time')];\n    case 'controllers':\n      return [utf8ToBytes('canister'), canisterUint8Array, utf8ToBytes('controllers')];\n    case 'module_hash':\n      return [utf8ToBytes('canister'), canisterUint8Array, utf8ToBytes('module_hash')];\n    case 'subnet':\n      return [utf8ToBytes('subnet')];\n    case 'candid':\n      return [\n        utf8ToBytes('canister'),\n        canisterUint8Array,\n        utf8ToBytes('metadata'),\n        utf8ToBytes('candid:service'),\n      ];\n    default: {\n      // Check for CustomPath signature\n      if ('key' in path && 'path' in path) {\n        // For simplified metadata queries\n        if (typeof path['path'] === 'string' || path['path'] instanceof Uint8Array) {\n          const metaPath = path.path;\n          const encoded = typeof metaPath === 'string' ? utf8ToBytes(metaPath) : metaPath;\n\n          return [utf8ToBytes('canister'), canisterUint8Array, utf8ToBytes('metadata'), encoded];\n\n          // For non-metadata, return the provided custompath\n        } else {\n          return path['path'];\n        }\n      }\n    }\n  }\n  throw UnknownError.fromCode(\n    new UnexpectedErrorCode(\n      `Error while encoding your path for canister status. Please ensure that your path ${path} was formatted correctly.`,\n    ),\n  );\n};\n\n// Controllers are CBOR-encoded buffers\nconst decodeControllers = (buf: Uint8Array): Principal[] => {\n  const controllersRaw = cbor.decode<Uint8Array[]>(buf);\n  return controllersRaw.map(buf => {\n    return Principal.fromUint8Array(buf);\n  });\n};\n"]}